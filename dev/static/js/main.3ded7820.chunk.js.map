{"version":3,"sources":["back-end/utils.js","back-end/graph.js","back-end/parse-mcf.js","back-end/parse-tmcf.js","back-end/server-api.js","utils.js","Header.js","TriplesTable.js","DisplayNode.js","App.js","index.js"],"names":["API_ROOT","getRemotePropertyLabels","dcid","a","targetUrl","fetch","then","res","json","data","JSON","parse","payload","getRemotePropertyValues","label","isInverse","triples","in","out","getValueFromValueObj","valueObj","Error","value","Node","getNode","setDCID","existsInKG","doesExistsInKG","url","shouldReadLine","line","startsWith","length","id","this","localId","alreadyFetched","assertions","invAssertions","dcidRef","localRef","join","trim","remote","nodeHash","mergeNode","absorbedNode","getAssertions","forEach","assert","src","nextAssertion","getInvAssertions","invAssert","target","invNextAssertion","propLabels","valueList","val","isNode","foundMatch","source","inv","property","provenance","provenanceId","Assertion","allLabels","createAssertionsFromLabels","outLabels","inLabels","assertList","push","invAssertList","obj","existing","newNode","Object","NAMESPACES","ParseMcf","fileName","prov","curNode","lineNum","propValues","values","split","propValue","namespace","includes","substring","indexOf","parsedValues","toString","nodeId","ns","localNodeHash","replace","propLabel","parsePropValues","setCurNode","setCurNodeDCID","createAssertionsFromParsedValues","mcf","lines","parseLine","file","fileReader","FileReader","readAsText","Promise","rej","addEventListener","result","mcfParser","name","parseMcfStr","getArrowId","getEntityID","localIdMatch","match","getLocalIdFromEntityId","entityID","index","parsePropertyValues","csvRow","parsedValue","colName","fillTemplateFromRow","template","filledTemplate","csvToMCF","csvRows","mcfStrList","row","readCSVFile","csvFile","csv","fromString","console","log","readTMCFFile","tmcfFile","tmcfCSVToMCF","fileList","endsWith","mcfFile","readFile","localHash","keys","ParseTMCF","retrieveNode","shouldCreateRemote","foundNode","isNodeObj","getElemId","setExistsInKG","fileHash","goToId","window","location","hash","openFile","fileUrl","open","secondWindow","closed","alert","Header","event","keyCode","utils","className","onClick","type","onKeyUp","handleSearch","placeholder","Component","getMissingVal","API","elemId","getRef","onProvClick","getRowFromTriple","missingVal","provId","provName","rowClassName","provNames","pop","key","asserts","tripleRows","tripleRow","TriplesTable","props","state","tableRows","loading","prevProps","setState","getTripleRows","inverse","rows","tableHeaders","DisplayNode","ref","invAsserts","fetching","setNodeData","node","fetchRemoteData","table","App","subjNodes","firstLoad","searchErrMsg","handleHashChange","loadUrlFiles","params","URLSearchParams","fileUrls","getAll","loadRemoteFiles","fileUrlList","searchDCId","get","searchId","err","errMsg","i","submitFileList","xhr","XMLHttpRequest","responseType","onload","response","URL","concat","send","subjList","display","map","onClearPress","onChange","Array","from","files","accept","required","multiple","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3ded7820.chunk.js","sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Module contains helper functions for api calls to data commons as well as\n * helper functions for parsing file to create local knowledge graph.\n */\n\nimport {Node} from './graph.js';\nconst API_ROOT = 'https://api.datacommons.org';\n\n/**\n * Gets all property labels of the given dcid that are in the DC KG.\n *\n * @param {string} dcid The dcid of the node to find property labels for.\n * @return {Object} An object containing both 'in' and 'out' property labels.\n */\nasync function getRemotePropertyLabels(dcid) {\n  const targetUrl = API_ROOT + '/node/property-labels?dcids=' + dcid;\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid]);\n}\n\n/**\n * Gets all property values containing the given dcid, property label, and\n * direction.\n *\n * @param {string} dcid The dcid of the node to find property value for.\n * @param {string} label The property label to query for.\n * @param {boolean} isInverse Direction of property label, false indicates\n *     an outgoing label, true is an incoming label.\n * @return {Object} An object containing all found values matching the query.\n */\nasync function getRemotePropertyValues(dcid, label, isInverse) {\n  const direction = isInverse ? 'in' : 'out';\n  const targetUrl =\n      (API_ROOT + '/node/property-values?limit=500&dcids=' + dcid +\n       '&property=' + label + '&direction=' + direction);\n\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid])\n      .then((triples) => isInverse ? triples.in : triples.out);\n}\n\n/**\n * Parses an Object returned from the DC REST get_values API to create a Node\n * object from the value's dcid or to return the string value that the object\n * holds.\n *\n * @param {Object} valueObj An object returned from DC REST get_values API.\n * @return {Node | string} The created Node if the value object has a dcid,\n *     otherwise the string of the value.\n */\nfunction getValueFromValueObj(valueObj) {\n  if (!('dcid' in valueObj || 'value' in valueObj)) {\n    throw new Error('ERROR remote fetch no dcid or value prop: ' + valueObj);\n  }\n\n  if ('dcid' in valueObj) {\n    const value = Node.getNode(valueObj.dcid);\n    value.setDCID(valueObj.dcid);\n    value.existsInKG = true;\n    return value;\n  }\n  return valueObj.value;\n}\n\n/**\n * Queries Data Commons to determine if a given dcid is a part of any\n * triples in the Knowledge graph.\n * @param {string} dcid The dcid to check if exists in Data Commons\n * @return {Promise<boolean>} Returns true if given dcid is in any triples in\n *     Data Commons Knowledge Graph.\n */\nasync function doesExistsInKG(dcid) {\n  const url = API_ROOT + '/node/triples?dcids=' + dcid + '&limit=1';\n  return fetch(url)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid] ? true : false);\n}\n\n/**\n * Indicates if a line should be parsed.\n * @param {string} line The line to be checked.\n * @return {boolean} False if the line is a comment or empty, otherwise\n *     true.\n */\nfunction shouldReadLine(line) {\n  if (line.startsWith('//') || line.length === 0 || line.startsWith('#')) {\n    return false;\n  }\n  return true;\n}\n\nexport {\n  getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n  doesExistsInKG,\n  shouldReadLine,\n};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Module contains Node and Assertion classes which together create a local\n * version of the Data Commons Knowledge Graph.\n */\n\nimport {\n  doesExistsInKG,\n  getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n} from './utils.js';\n\n/** Class representation of a single Node in the KG. */\nclass Node {\n  /**\n   * Universal id of the node. Every Node obj has a localId, which is either a\n   * local reference used in an uplaoded file, or the dcid if the node is never\n   * referred to locally (remote only Node).\n   * @type {string}\n   */\n  localId;\n  /**\n   * Whether triples from the remote Data Commons Knowledge Graph have already\n   * been fetched.\n   * @type {boolean}\n   */\n  alreadyFetched;\n  /**\n   * Whether the node exists in the Data Commons Knowledge Graph.\n   * @type {boolean}\n   */\n  existsInKG;\n  /**\n   * Dcid of the node. Set only if a remote id is referred to in a local file or\n   * pulled from the Data Commons Knowledge Graph.\n   * @type {?string}\n   */\n  dcid;\n  /**\n   * The head of a linked list of Assertion objects representing the outgoing\n   * triples of the Node object.\n   * @type {?Assertion}\n   */\n  assertions;\n  /**\n   * The head of a linked list of Assertion objects representing the incoming\n   * triples of the Node object.\n   * @type {?Assertion}\n   */\n  invAssertions;\n\n  /**\n   * Create a Node based on a given id.\n   * @param {string} id The id of the node to create.\n   */\n  constructor(id) {\n    this.localId = id;\n    this.alreadyFetched = false;\n    this.existsInKG = false;\n    this.dcid = null;\n    this.assertions = null;\n    this.invAssertions = null;\n  }\n\n  /**\n   * Indicates if a given object is an instance of Node class.\n   * @param {Object} obj The object to check.\n   * @return {boolean} True if the object is an instance of Node.\n   */\n  static isNode(obj) { return obj instanceof Node; }\n\n  /**\n   * Returns a node with the given ID, creates a new node if shouldCreate is\n   * true, or null if the node does not exist and a node should not be created.\n   *\n   * @param {string} id The id of the node to find.\n   * @param {boolean} shouldCreate True if a new Node should be created if it\n   *     does not already exist.\n   * @return {Node|null} The found node if it exists or is created.\n   */\n  static getNode(id) {\n    const existing = Node.nodeHash[id];\n    if (existing) {\n      return existing;\n    }\n\n    const newNode = new Node(id);\n    Node.nodeHash[id] = newNode;\n    return newNode;\n\n  }\n\n  /**\n   * Returns the reference to the node that is displayed in browser. If the\n   * node has a dcid, then the dcid will be displayed. If the node's local id\n   * is different, then the local id is also displayed.\n   * Ex: <dcid> [l:<localId>]\n   * @return {string} The reference to the node to be displayed.\n   */\n  getRef() {\n    const dcidRef = this.dcid ? this.dcid : '';\n    let localRef = '';\n\n    if (!this.dcid || this.dcid !== this.localId) {\n      localRef = '[l:' + this.localId + ']';\n    }\n    return [ dcidRef, localRef ].join(' ').trim();\n  }\n\n  /**\n   * Sets the dcid of Node object. Checks if a separate node based on the dcid\n   * already exists. If remote node exists, then the remote node is absorbed by\n   * current node via mergeNode() method.\n   *\n   * @param {string} dcid The dcid to be added to the Node object.\n   */\n  setDCID(dcid) {\n    const remote = Node.nodeHash[dcid];\n    if (remote && remote != this) {\n      this.mergeNode(remote);\n    }\n    this.dcid = dcid;\n    Node.nodeHash[dcid] = this;\n  }\n\n  /**\n   * Moves the assertions and inverse Assertions from the given param node to\n   * the calling Node object by changing the src property for assertions and the\n   * target property of the invAssertions.\n   *\n   * @param {Node} absorbedNode The node object whose triples should be copied.\n   */\n  mergeNode(absorbedNode) {\n    if (this.localId === absorbedNode.localId) {\n      return;\n    }\n\n    absorbedNode.getAssertions().forEach((assert) => {\n      assert.src = this;\n      assert.nextAssertion = this.assertions;\n      this.assertions = assert;\n    });\n\n    absorbedNode.getInvAssertions().forEach((invAssert) => {\n      invAssert.target = this;\n      invAssert.invNextAssertion = this.invAssertions;\n      this.invAssertions = invAssert;\n    });\n  }\n\n  /**\n   * Sets the property existsInKG to true if the Node has triples in the DC KG.\n   */\n  async setExistsInKG() {\n    if (!this.dcid || this.existsInKG) {\n      return;\n    }\n    this.existsInKG = await doesExistsInKG(this.dcid);\n  }\n\n  /**\n   * Creates Assertion objects from a list of property labels by calling the\n   * helper function getRemotePropertyValues from utils.js to find the values\n   * in Data Commons given the current node, a property label, and the direction\n   * of the label.\n   *\n   * @param {Array<string>} propLabels List of property labels associated with\n   *     the calling Node object in Data Commons.\n   * @param {boolean} isInverse True if the list of labels are incoming labels,\n   *     meaning the calling Node object is the target of the triple. False if\n   *     the calling Node is the source of the triple.\n   */\n  async createAssertionsFromLabels(propLabels, isInverse) {\n    for (const label of propLabels) {\n      await getRemotePropertyValues(this.dcid, label, isInverse)\n          .then((valueList) => {\n            if (!valueList) {\n              throw new Error('No property values for dcid: ' + this.dcid +\n                              ' label: ' + label);\n            }\n\n            valueList.forEach((valueObj) => {\n              const val = getValueFromValueObj(valueObj);\n\n              if(isInverse && !Node.isNode(val)){\n                  throw new Error('Error creating assertion with non Node source');\n                }\n\n              const source = isInverse ? val : this;\n              const target = isInverse ? this : val;\n              let foundMatch;\n\n              // bug fix 9 Oct 2020, prevent appending duplicate assertions\n              if(isInverse){\n                for (const inv of this.getInvAssertions()){\n                  if (inv.src === source && inv.property === label && inv.provenance ===  valueObj.provenanceId){\n                    foundMatch = true;\n                  }\n                }\n                if (!foundMatch){\n                  new Assertion(source, label, target, valueObj.provenanceId);\n\n                }\n              } else{\n                for (const assert of this.getAssertions()){\n                if (assert.target === target && assert.property === label && assert.provenance === valueObj.provenanceId){\n                  foundMatch = true;\n                }\n              }\n                if (!foundMatch){\n                  new Assertion(source, label, target, valueObj.provenanceId);\n              }\n            }\n            });\n          });\n    }\n  }\n\n  /**\n   * Stores remote triples as assertions and inverse Assertions of the calling\n   * Node object. Sets the alreadyFetched property to true if data is fetched.\n   */\n  async fetchRemoteData() {\n    if (this.alreadyFetched || !this.dcid) {\n      return;\n    }\n\n    await getRemotePropertyLabels(this.dcid).then(async (allLabels) => {\n      await this.createAssertionsFromLabels(allLabels.outLabels,\n                                            /* isInverse */ false);\n      await this.createAssertionsFromLabels(allLabels.inLabels,\n                                            /* isInverse */ true);\n    });\n    this.alreadyFetched = true;\n  }\n\n  /**\n   * Returns the linked list of assertions of the calling Node as an Array.\n   * @return {Array<Assertion>} The array of assertions.\n   */\n  getAssertions() {\n    const assertList = [];\n    let assert = this.assertions;\n\n    while (assert) {\n      assertList.push(assert);\n      assert = assert.nextAssertion;\n    }\n    return assertList;\n  }\n\n  /**\n   * Returns the linked list of inverse assertions of the calling Node as an\n   * Array.\n   * @return {Array<Assertion>} The array of Inverse assertions.\n   */\n  getInvAssertions() {\n    const invAssertList = [];\n\n    let invAssert = this.invAssertions;\n    while (invAssert) {\n      invAssertList.push(invAssert);\n      invAssert = invAssert.invNextAssertion;\n    }\n    return invAssertList;\n  }\n}\n\nNode.nodeHash = {}; // stores all created nodes\n\n/** Class representation of a single Assertion or triple in the KG. */\nclass Assertion {\n  /**\n   * The source or subject of the triple.\n   * @type {Node}\n   */\n  src;\n  /**\n   * The property label or predicate of the triple.\n   * @type {string}\n   */\n  property;\n  /**\n   * The provenance of the triple.\n   * @type {string}\n   */\n  provenance;\n  /**\n   * The target or object of the triple.\n   * @type {string|Node}\n   */\n  target;\n  /**\n   * The next Assertion object in a linked list representing the outgoing\n   * triples of the Node object stored in src property.\n   * @type {?Assertion}\n   */\n  nextAssertion;\n  /**\n   * The next Assertion object in a linked list representing the incoming\n   * triples of the Node object stored in src property.\n   * @type {?Assertion}\n   */\n  invNextAssertion;\n\n  /**\n   * Create a triple, setting the source's assertion prop to be the new object.\n   *\n   * @param {Node} src The source or subject of the triple.\n   * @param {string} property The property label of the triple.\n   * @param {Node|string} target The predicate or target of the triple.\n   * @param {string} provenance The provenance of the triple.\n   */\n  constructor(src, property, target, provenance) {\n    this.src = src;\n    this.property = property;\n    this.provenance = provenance;\n    this.target = target;\n    this.nextAssertion = src.assertions;\n    src.assertions = this;\n\n    if (target instanceof Object) {\n      this.invNextAssertion = target.invAssertions;\n      target.invAssertions = this;\n    }\n  }\n}\nexport {Node, Assertion};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parses an mcf file and creates local knowledge graph of the parsed data\n * using Node and Assertion Class objects.\n */\n\nimport {Assertion, Node} from './graph.js';\nimport {shouldReadLine} from './utils.js';\nconst NAMESPACES = [ 'l', 'schema', 'dcs', 'dcid' ];\nconst LOCAL_NS = 'l';\n\n/** Class responsible for parsing an mcf file. */\nclass ParseMcf {\n  /**\n   * Provenance to be used for any Assertion objects created during parsing,\n   * based off of the mcf file name.\n   * @type {string}\n   */\n  prov;\n  /**\n   * Current subject Node for any Assertion created. Set when a 'Node:' property\n   * label is parsed.\n   * @type {Node}\n   */\n  curNode;\n  /**\n   * Current line number of the line being parsed, used for identifying location\n   * of syntax error in the mcf file.\n   * @type {number}\n   */\n\n  lineNum;\n  /**\n   * Create a ParseMcf object which keeps tracks of the current source node of\n   * each triple in the mcf and the provenance, which is the mcf file name.\n   * @param {string} fileFullName Name of file to be converted to a provenance\n   *     representing the file in teh Assertion Objects created while parsing.\n   */\n  constructor(fileName) {\n\n    this.prov = fileName;\n    this.curNode = null;\n    this.lineNum = -1;\n  }\n\n  /**\n   * Parses a string represetnaing a comma separated list of property values\n   * from a line of an mcf file. Returns a list having either a string or\n   * <namespace, reference> pair.\n   *\n   * @param {string} propValues A comma separated list of property values.\n   * @return {Array<(string|Object)>} Array of\n   *     parsed values.\n   */\n  parsePropValues(propValues) {\n    const values = [];\n    // split propValues on commas which are not enclosed by double quotes\n    for (const propValue of propValues.split(/,(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)) {\n      const namespace = propValue.split(':')[0].trim();\n      if (NAMESPACES.includes(namespace)) {\n        values.push({\n          'ns' : namespace,\n          'ref' : propValue.substring(propValue.indexOf(':') + 1).trim(),\n        });\n      } else{\n      values.push(propValue.trim());\n    }\n  }\n    return values;\n  }\n\n  /**\n   * Sets curNode variable of the calling ParseMcf object based on the passed in\n   * parsed values of a line of mcf, given the property label for the line was\n   * 'Node'. The parsed value either is a local reference with or without the\n   * 'l' namespace, or it has a remote namespace. If the namespace is remote,\n   * then the dcid for curNode is set. Updates localNodeHash mapping to store\n   * the subject nodes to be displayed in home screen of browser.\n   *\n   * @param {Array<string|Object>} parsedValues The array of parsed values from\n   *     a line of mcf with property label of 'Node'.\n   */\n  setCurNode(parsedValues) {\n    if (parsedValues.length !== 1) {\n      throw new Error('Error in declaring node (line ' + this.lineNum +\n                      '): ' + parsedValues.toString());\n    }\n\n    let nodeId = parsedValues[0];\n    let dcid = '';\n\n\n    if (parsedValues[0] instanceof Object) {\n      let ns = parsedValues[0]['ns'];\n      if (ns === 'dcid') {\n        dcid = parsedValues[0]['ref'];\n        nodeId = 'dcid:' + parsedValues[0]['ref'];\n      } else if (NAMESPACES.includes(ns)) {\n        throw new Error('Error with namespace in declaring node (line ' +\n          this.lineNum +  '): namespace: ' + parsedValues[0]['ns']);\n      }\n    }\n\n    this.curNode = Node.getNode(nodeId);\n    if (dcid) this.curNode.setDCID(dcid);\n\n    ParseMcf.localNodeHash[nodeId] = this.curNode;\n  }\n\n  /**\n   * Sets the dcid of the curNode variable of the calling ParseMcf object given\n   * the property label of the line being parsed is 'dcid'.\n   * @param {Array<string|Object>} parsedValues The array of parsed values from\n   *     a line of mcf with property label of 'dcid'.\n   */\n  setCurNodeDCID(parsedValues) {\n    const errStrEnding = '(line ' + this.lineNum +'): ' + parsedValues;\n    if (!this.curNode) {\n      throw new Error('ERROR (line ' + this.lineNum +'): ' +\n       'current node must be set before setting dcid');\n    }\n    if (parsedValues.length !== 1) {\n      throw new Error('ERROR (line ' + this.lineNum +'): ' +\n      'a node can only have one dcid');\n    }\n    if (typeof parsedValues[0] !== 'string') {\n      throw new Error('ERROR (line ' + this.lineNum +'): ' +\n      'dcid property must be a string, not a node reference');\n    }\n\n    this.curNode.setDCID(parsedValues[0].replace(/\"/g, ''));\n  }\n\n  /**\n   * Create Assertion objects using curNode variable of calling ParseMcf object\n   * as the source of the triple and the prov variable of the ParseMcf object\n   * as the provenance of the triple.One Assertion object is created for each\n   * parsed value given in the array parsedValues.\n   *\n   * @param {string} propLabel The property label of the triple to be created.\n   * @param {Array<string|Object>} parsedValues The parsed values from a line of\n   *     mcf, used to create the target for each created triple.\n   */\n  createAssertionsFromParsedValues(propLabel, parsedValues) {\n    for (const val of parsedValues) {\n      let target = val;\n      if (val instanceof Object) {\n        target = Node.getNode(val['ref']);\n        if (val['ns'] !== LOCAL_NS) {\n          target.setDCID(val['ref']);\n        }\n      }\n      new Assertion(this.curNode, propLabel, target, this.prov);\n    }\n  }\n\n  /**\n   * Parses a single line of an mcf file. First determines if the line should be\n   * read, then finds the property label, then the property values and creates\n   * an Assertion object based on the triple, given the calling object has a\n   * curNode property that acts as the source  and a prov property that gives\n   * the provenance for the triple.\n   *\n   * @param {string} line The line of mcf to be parsed.\n   */\n  parseLine(line) {\n    line = line.trim();\n\n    if (!shouldReadLine(line)) {\n      return;\n    } // not an error\n\n    if (!line.includes(':')) {\n      throw new Error('Error, line ' + this.lineNum + ' does not contain \":\"');\n    }\n\n    const propLabel = line.split(':', 1)[0].trim();\n    const propValues = line.substring(line.indexOf(':') + 1);\n\n    if (!propLabel || !propValues){\n      throw new Error('Error, (line ' + this.lineNum + '): ' + line);\n    }\n\n    // parsePropValues() returns a list having either a string or <namespace,\n    // reference> pair.\n    const parsedValues = this.parsePropValues(propValues);\n\n    switch (propLabel) {\n\n    case 'Node':\n      this.setCurNode(parsedValues);\n      break;\n\n    case 'dcid':\n      this.setCurNodeDCID(parsedValues);\n      break;\n\n    default:\n      this.createAssertionsFromParsedValues(propLabel, parsedValues);\n    }\n  }\n\n  /**\n   * Parses each line of the given string of an mcf file after setting the prov\n   * property of the calling ParseMcf object.\n   * @param {string} mcf The string representation of an mcf file to parse.\n   * @param {string} fileName The name of file that mcf string comes from.\n   * @return {Object} The mapping from local subject id to node, for home page.\n   */\n  parseMcfStr(mcf) {\n    const lines = mcf.split('\\n');\n    this.lineNum = 1;\n\n    lines.forEach((line) => {\n      this.parseLine(line);\n      this.lineNum++;\n    });\n\n    return ParseMcf.localNodeHash;\n  }\n\n  /**\n   * Reads an mcf file into a string, then creates ParseMcf object to parse the\n   * string.\n   * @param {FileObject} file An mcf file from the html file-input element.\n   * @return {Promise} Promise resolves to Node.nodeLocalHash after parsing mcf.\n   */\n  static readFile(file) {\n    const fileReader = new FileReader();\n    fileReader.readAsText(file);\n\n    return new Promise((res, rej) => {\n      fileReader.addEventListener('loadend', (result) => {\n        const mcfParser = new ParseMcf(file.name);\n        res(mcfParser.parseMcfStr(fileReader.result));\n      });\n\n      fileReader.addEventListener('error', rej);\n    });\n  }\n}\n\nParseMcf.localNodeHash = {}; // stores mapping of mcf subject IDs to the Node\n\nexport {ParseMcf};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as csv from 'csvtojson';\n\nimport {shouldReadLine} from './utils.js';\n\n/**\n * Returns the string following '->' in  a given string. Used for getting csv\n * column name when filling in tmcf with values from csv.\n * Ex:   C:SomeDataset->GeoId would return 'GeoId'\n * @param {string} propValue The string to look for a column name in.\n * @return {string|null} The column name that comes after '->'.\n */\nfunction getArrowId(propValue) {\n  if (propValue.includes('->')) {\n    return propValue.split('->')[1];\n  }\n  return null;\n}\n\n/**\n * Returns a string matching the format E:'DataSet Name'->'Entity #'.\n * @param {string} line The string to look for a match in.\n * @return {string|null} The entity id that matches the specified format.\n */\nfunction getEntityID(line) {\n  const localIdMatch = line.match('E:(.*)->(.*)');\n  if (localIdMatch) {\n    return localIdMatch[0];\n  }\n  return null;\n}\n\n/**\n * Generates a local id for a node of specfic row in csv from an entity id used\n * in tmcf file.\n * Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n * @param {string} entityID The entity id used in tmcf file.\n * @param {string} index The row number in the csv of the node to be created.\n * @return {string|null} The local id for the node of the specific csv row.\n */\nfunction getLocalIdFromEntityId(entityID, index) {\n  if (entityID) {\n    return entityID.replace('->', '_').replace('E:', '') + '_R' + index;\n  }\n  return null;\n}\n\n/**\n * Converts propertyValues from a line of tmcf to mcf by either converting\n * entity ids to local ids or replacing a csv column reference with the actual\n * value from the csv.\n *\n * @param {string} propValues The property values from the line of TMCF.\n * @param {Object} csvRow The JSON representation of a single row of a csv file.\n *     The keys are the column names and values are the corresponding entries of\n *     the csv for the specfic row/column.\n * @param {number} index The row number of the csvRow, used to generate a local\n *     id if needed.\n * @return {string} The mcf version of the given propValues which has local ids\n *     in lieu of entity ids and csv column references replaces with csv values.\n */\nfunction parsePropertyValues(propValues, csvRow, index) {\n  const parsedValues = [];\n\n  for (const propValue of propValues.split(',')) {\n    let parsedValue = propValue;\n\n    const entityID = getEntityID(propValue);\n\n    // convert entity id format to local id format\n    // Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n    if (entityID) {\n      const localId = 'l:' + getLocalIdFromEntityId(entityID, index);\n      parsedValue = parsedValue.replace(entityID, localId);\n    } else {\n      // Replace csv column placeholder with the value\n      const colName = getArrowId(propValue);\n      parsedValue = parsedValue.replace(/C:(.*)->(.*)/, csvRow[colName]);\n    }\n    parsedValues.push(parsedValue);\n  }\n  return parsedValues.join(',');\n}\n\n/**\n * Convert a row of csv to mcf using the tmcf as a template.\n * @param {string} template The string representation of tmcf file.\n * @param {Object} csvRow The JSON representation of a single row of a csv file.\n *     The keys are the column names and values are the corresponding entries of\n *     the csv for the specfic row/column.\n * @param {number} index The row number of the csvRow, used to generate a local\n *     id if needed.\n * @return {string} The constructed mcf for the single row from csv file.\n */\nfunction fillTemplateFromRow(template, csvRow, index) {\n  const filledTemplate = [];\n  for (const line of template.split('\\n')) {\n    if (!line.trim()) {\n      filledTemplate.push('');\n      continue;\n    }\n\n    if (!shouldReadLine(line)) {\n      continue;\n    }\n\n    const propLabel = line.split(':')[0].trim();\n\n    // TODO make this better\n    const propValues = line.replace(propLabel + ':', '').trim();\n\n    if (propLabel === 'Node'){\n      if (propValues.includes(',')){\n        throw new Error('cannot have multiple ids for Node declaration');\n      }\n      let id = propValues;\n      const entityID = getEntityID(propValues);\n      if(entityID) id = getLocalIdFromEntityId(entityID, index);\n      filledTemplate.push(propLabel + ': ' + id);\n    }else{\n\n    const parsedValues = parsePropertyValues(propValues, csvRow, index);\n    filledTemplate.push(propLabel + ': ' + parsedValues);\n  }\n}\n  return filledTemplate.join('\\n');\n}\n\n/**\n * Creates an mcf string from a string representation of TMCF file and the json\n * representation of a CSV file. The tmcf is populated with csv files for each\n * row of the csv.\n * @param {string} template The string representation of a tmcf file.\n * @param {Array<Object>} csvRows The json representation of the csv file. Each\n *     Object element of the array represents one row of the csv.\n * @return {string} The created mcf as a string.\n */\nfunction csvToMCF(template, csvRows) {\n  let index = 1;\n  const mcfStrList = [];\n  for (const row of csvRows) {\n    mcfStrList.push(fillTemplateFromRow(template, row, index));\n    index += 1;\n  }\n  return mcfStrList.join('\\n');\n}\n\n/**\n * Converts CSV file to an array of JS Object where each JS Object in the array\n * represents one row of the csv. The keys of the object are the column header\n * names and the values of the object are the csv entries in that column of the\n * given row the object represents.\n * @param {string} template The string representation of a tmcf file.\n * @param {FileObject} csvFile THe csv file from html file-input element.\n * @return {Array<Object>} The json representation of the csv file.\n */\nasync function readCSVFile(template, csvFile) {\n  const fileReader = new FileReader();\n  fileReader.readAsText(csvFile);\n  return new Promise((res, rej) => {\n    fileReader.addEventListener('loadend', (result) => {\n      csv().fromString(fileReader.result).then((csvRows) => {\n        console.log('csvFile: ' + csvFile.name);\n        const mcf = csvToMCF(template, csvRows);\n        res(mcf);\n      });\n    });\n    fileReader.addEventListener('error', rej);\n  });\n}\n\n/**\n * Reads a tmcf file and returns the contents as a string\n * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n * @return {string} The string representation of the tmcf file.\n */\nasync function readTMCFFile(tmcfFile) {\n  const fileReader = new FileReader();\n  fileReader.readAsText(tmcfFile);\n  return new Promise((res, rej) => {\n    fileReader.addEventListener('loadend',\n                                (result) => { res(fileReader.result); });\n    fileReader.addEventListener('error', rej);\n  });\n}\n\n/**\n * Converts a TMCF file and CSV file to an MCF string.\n * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n * @param {FileObject} csvFile THe csv file from html file-input element.\n * @return {string} The translated mcf as a string.\n */\nasync function tmcfCSVToMCF(tmcfFile, csvFile) {\n  return readTMCFFile(tmcfFile).then((template) =>\n                                         readCSVFile(template, csvFile));\n}\n\nexport {\n  tmcfCSVToMCF,\n  csvToMCF,\n  fillTemplateFromRow,\n  getLocalIdFromEntityId,\n  getEntityID,\n  getArrowId,\n  parsePropertyValues,\n};\n","import {Node} from './graph.js';\nimport {ParseMcf} from './parse-mcf.js';\nimport * as ParseTMCF from './parse-tmcf.js';\n\n/**\n * Parses App state's fileList to find either one mcf file or one set of\n * tmcf+csv. Parses the files according to their file type.\n * @param {Array<FileBlob>} fileList The list of files to load into memory.\n * @return {Array<string>} An array of local ids from Node.nodeLocalHash.\n */\nasync function readFileList(fileList) {\n  let tmcfFile;\n  let csvFile;\n  let mcfFile;\n  for (const file of fileList) {\n    if (file.name.endsWith('.tmcf')) {\n      tmcfFile = file;\n    } else if (file.name.endsWith('.csv')) {\n      csvFile = file;\n    } else {\n      mcfFile = file;\n    }\n  }\n\n  if (mcfFile) {\n    return ParseMcf.readFile(mcfFile).then((localHash) =>\n                                               Object.keys(localHash));\n  }\n\n  if (tmcfFile && csvFile) {\n    return ParseTMCF.tmcfCSVToMCF(tmcfFile, csvFile)\n        .then((mcf) => {\n          console.log(mcf);\n          const mcfParser = new ParseMcf(tmcfFile.name + '&' + csvFile.name);\n          return mcfParser.parseMcfStr(mcf);\n        })\n        .then((localHash) => Object.keys(localHash));\n  }\n  return [];\n}\n\nfunction clearFiles() {\n  Node.nodeHash = {};\n  ParseMcf.localNodeHash = {};\n}\n\nfunction retrieveNode(id, shouldCreateRemote) {\n  const foundNode = Node.getNode(id);\n  // should make dcid from search bar\n  if (shouldCreateRemote && !(foundNode.dcid)) {\n    foundNode.setDCID(id);\n  }\n  console.log('retrieve');\n  console.log(foundNode);\n  return foundNode;\n}\n\nfunction isNodeObj(obj) { return Node.isNode(obj); }\n\nasync function getElemId(target) {\n  if (!target) {\n    return null;\n  }\n  if (target.existsInKG) {\n    return 'blue';\n  }\n\n  return target.setExistsInKG().then(() => {\n    if (target.existsInKG) {\n      return 'blue';\n    }\n\n    if (!target.dcid && target.localId &&\n        target.localId in ParseMcf.localNodeHash) {\n      return 'purple';\n    }\n\n    if (!target.dcid && !(target.localId in ParseMcf.localNodeHash)) {\n      return 'orange';\n    }\n    return 'red';\n  });\n}\n\nfunction localNodeHashExists() {\n  return (ParseMcf.localNodeHash) ? true : false;\n}\nexport {\n  readFileList,\n  clearFiles,\n  retrieveNode,\n  isNodeObj,\n  getElemId,\n  localNodeHashExists,\n};\n","import * as API from './back-end/server-api.js';\n\nlet fileHash ='#';\n/**\n * Sets the window hash value to query a given id.\n * @param {string} id The id of the desired node to display. This can be either\n *     a dcid or a local id.\n */\nfunction goToId(id) {\n  if(id.includes('dcid:')){\n  window.location.hash = fileHash + '&dcid=' + id.replace('dcid:', '');\n} else if (API.localNodeHashExists()){\n  window.location.hash = fileHash + '&id=' + id;\n} else{\n  window.location.hash = fileHash + '&error=noLocalFiles';\n}\n}\n\n/**\n * Sets the window hash value to empty to redirect user to home page.\n */\nfunction goToHome() {\n  console.log(fileHash)\n  window.location.hash = fileHash;\n}\n\nfunction setFileHash(fileUrlList){\n  fileHash = '#'\n  for (const fileUrl of fileUrlList){\n    fileHash += '&file=' + fileUrl;\n  }\n}\n\nfunction openFile(fileUrl){\n  if (!fileUrl.includes('&')){\n    window.open(fileUrl);\n    return;\n  }\n\n  window.open(fileUrl.split('&')[0]);\n  const secondWindow = window.open(fileUrl.split('&')[1]);\n  if(!secondWindow || secondWindow.closed || typeof secondWindow.closed=='undefined'){\n    //POPUP BLOCKED\n    alert('Tab blocked: ' + fileUrl.split('&')[1] + '\\n\\nEnable PopUps to open both .csv and .tmcf files!!')\n  }\n}\n\nexport {goToId, goToHome, setFileHash, openFile};\n","import React, {Component} from 'react';\nimport * as utils from './utils.js';\nimport './App.css';\n\n/** Header component contains the id search bar and return home button. */\nclass Header extends Component {\n  /**\n   * Calls utils method goToId to search for an id when the user presses enter.\n   * @param {Event} event OnKeyUp  event from html search input element.\n   */\n  handleSearch(event) {\n    if (event.keyCode === 13) {\n      utils.goToId(event.target.value);\n    }\n  }\n  /** Renders header element. */\n  render() {\n    return (\n      <div className='header'>\n        <button onClick = {() => utils.goToHome() }>Return Home</button>\n        <input type=\"search\" onKeyUp={this.handleSearch}\n          placeholder=\"Search id, use 'dcid:' namespace for remote lookup...\" />\n      </div>\n    );\n  }\n}\nexport {Header};\n","import React, {Component} from 'react';\nimport './App.css';\nimport * as API from './back-end/server-api.js';\nimport * as utils from './utils.js';\n\n/**\n * Returns an html element of the missing cell value in a triple. If the current\n * triple is an outgoing assertion (current node displayed is the source of the\n * triple) then this method will be called on the target. If the current triple\n * is an inverse assertions, then this method is called on the source of the\n * triple.\n * Determines if the target is another node and should be\n * clickable, what color it should be, and the node reference that should be\n * displayed (dcid vs dcid [l:localId] vs [l:localId]). If the target is not\n * another node, then an html element of pure text is returned.\n * @param {Node|string} target The source of an inverse assertion or the target\n *     of a direct assertion.\n * @return {HtmlElement} A single cell of an html row representing a triple.\n *     Either the source or target of the triple depending if the triple is\n *     inverse or not.\n */\nasync function getMissingVal(target) {\n  if (API.isNodeObj(target)) {\n    const elemId = await API.getElemId(target);\n    return (\n      <td><p id={elemId} className='clickable' onClick={() =>\n        utils.goToId(target.localId)}>{target.getRef()}</p></td>\n    );\n  }\n  return (<td >{target}</td>);\n}\nfunction onProvClick(elemId, prov){\n  if(elemId){\n    utils.goToId(prov)\n  } else{\n    utils.openFile(prov)\n  }\n}\n/**\n * Returns an html element row representing the given assertion.\n * @param {Assertion} assert The assertion/triple to create the html row from.\n * @param {boolean} isInverse True if the assertion is inverse, meaning the\n *     currently displayed node is the target of the triple.\n * @param {number} index Used to create a unique key for the html row element.\n * @return {HtmlElement} A row represeting the given triple.\n */\nasync function getRowFromTriple(assert, isInverse, index ) {\n  const missingVal = isInverse ? assert.src : assert.target;\n  const val = await getMissingVal(missingVal);\n\n  let rowClassName;\n  let provId = 'black';\n  let provName = assert.provenance;\n  if(provName.startsWith('https')){\n    rowClassName = 'bold';\n    provId = '';\n    const provNames = [];\n    for (const fileName of provName.split('&')){\n      provNames.push(fileName.split('/').pop());\n    }\n    provName = provNames.join(', ');\n  }\n  return (\n    <tr className={rowClassName} key={assert.property + index}>\n      <td>{assert.property}</td>\n      {val}\n      <td><p id={provId} className='clickable'\n         onClick={() => onProvClick(provId, assert.provenance)}>{provName}</p></td>\n    </tr>\n  );\n}\n\n/**\n * Converts a list of Assertion objects to an array of HTML row elements that is\n * displyed in the TriplesTable.\n * @param {Array<Assertion>} asserts An array of Assertion objects to display in\n *     the TriplesTable component.\n * @param {boolean} isInverse True if the current node displayed is the target\n *     for each of the assertions.\n * @return {Array<HtmlElement>} The array of HTML row elements representing each\n *     triple.\n */\nasync function getTripleRows(asserts, isInverse) {\n  const tripleRows = [];\n  let index = 0; // used to create a unique key for each row element\n\n  for (const assert of asserts) {\n    const tripleRow = await getRowFromTriple(assert, isInverse, index);\n    tripleRows.push(tripleRow);\n    index += 1;\n  }\n  return tripleRows;\n}\n\nfunction getTableHeaders(isInverse) {\n  if (isInverse) {\n    return (\n      <tr>\n        <th>Property</th>\n        <th>Source</th>\n        <th>Provenance</th>\n      </tr>\n    );\n  }\n  return (\n    <tr>\n      <th>Property</th>\n      <th>Target</th>\n      <th>Provenance</th>\n    </tr>\n  );\n}\n\n/** Displays all given triples as a table */\nexport class TriplesTable extends Component {\n  /** Creates TriplesTable component. */\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      tableRows: null,\n      loading: true,\n    };\n  }\n\n  /**\n   * Gets rows of triples when the array of Assertions from props is updated.\n   * @param {Object} prevProps The previous props before the component updated,\n   *     used to compare if the passed in triples have been modified.\n   */\n  componentDidUpdate(prevProps) {\n    if (prevProps.triples !== this.props.triples) {\n      this.setState({loading: true});\n      getTripleRows(this.props.triples, this.props.inverse).then((rows) => {\n        this.setState({tableRows: rows, loading: false});\n      });\n    }\n  }\n\n  /** Renders TriplesTable component.   */\n  render() {\n    if (this.state.loading) return null;\n\n    const tableHeaders = getTableHeaders(this.props.inverse);\n\n    return (\n      <table>\n        <thead>\n          {tableHeaders}\n        </thead>\n        <tbody>{this.state.tableRows}</tbody>\n      </table>\n    );\n  }\n}\n","import * as API from './back-end/server-api.js';\nimport React, {Component} from 'react';\nimport {Header} from './Header.js';\nimport {TriplesTable} from './TriplesTable.js';\nimport './App.css';\n\n/** Displays node data for a given node passed in through props. */\nclass DisplayNode extends Component {\n  /** Creates DisplayNode component. */\n  constructor(props) {\n    super(props);\n    this.state = {\n      ref: null,\n      asserts: [],\n      invAsserts: [],\n      fetching: true,\n    };\n  }\n\n  /** Sets node data when the component mounts. */\n  componentDidMount() {\n    this.setNodeData();\n  }\n\n  /**\n   * Sets node data when the node to display changes.\n   * @param {Object} prevProps The previous props before the component updated,\n   *     used to compare if the passed in node has changed.\n   */\n  componentDidUpdate(prevProps) {\n    if (prevProps.node !== this.props.node) {\n      this.setNodeData();\n    }\n  }\n\n  /**\n   * Loads data to display for the node passed in through props. This includes\n   * fetching the remote data from DC KG for the node.\n   */\n  setNodeData() {\n    console.log(this.props.node);\n\n    const curNode = this.props.node;\n    this.setState({ref: curNode.getRef(), fetching: true});\n\n    API.getElemId(curNode)\n        .then((elemId) => this.setState({elemId: elemId}) );\n\n    curNode.fetchRemoteData().then( () => {\n      this.setState({fetching: false});\n     const assertList = curNode.getAssertions();\n     this.setState({asserts: assertList});\n     const invAssertList = curNode.getInvAssertions();\n     this.setState({invAsserts: invAssertList});\n    });\n  }\n\n  /** Renders the DisplayNode component. */\n  render() {\n    let table;\n    if (this.state.fetching) {\n      table = (\n        <div className='div-col'>\n          <br></br>\n            <div className='loadingSpinner'></div>\n            <h2>...fetching triples...</h2>\n\n        </div>\n      );\n    } else {\n      table = (\n        <div className='node'>\n          <h3 className='inline'>Assertions</h3>\n          <p className='inline'> - current node is source</p>\n          <TriplesTable triples={this.state.asserts} inverse={false}/>\n          <br></br>\n          <h3 className='inline'>Inverse Assertions</h3>\n          <p className='inline'> - current node is target</p>\n          <TriplesTable triples={this.state.invAsserts} inverse={true}/>\n        </div>\n      );\n    }\n\n    return (\n      <div>\n        <p className='inline'> | </p>\n        <p className='inline' id='blue'>Node has dcid that exists in DC KG</p>\n        <p className='inline'> | </p>\n        <p className='inline' id='purple'>Node has resolved local reference and no dcid</p>\n        <p className='inline'> | </p>\n        <p className='inline' id='orange'>Node has unresolved local reference and no dcid</p>\n        <p className='inline'> | </p>\n        <p className='inline' id='red'>Default; Node has dcid which does not exist in DC KG</p>\n        <p className='inline'> | </p>\n        <br></br>\n        <br></br>\n        <h1 className='inline'>Currently Viewing: </h1>\n        <h1 className='inline' id={this.state.elemId}>{this.state.ref}</h1>\n      <br></br>\n      {table}\n\n    </div>\n    );\n  }\n}\nexport default DisplayNode;\n","import React, {Component} from 'react';\nimport './App.css';\nimport * as API from './back-end/server-api.js';\nimport * as utils from './utils.js';\nimport {Header} from './Header.js';\nimport DisplayNode from './DisplayNode.js';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      subjNodes: [],\n      curNode: null,\n      fileList: [],\n      loading: null,\n      fileHash: '',\n      firstLoad: true,\n      searchErrMsg: '',\n    };\n  }\n  /** Adds an event listener to the window to respond to url hash changes. */\n  componentDidMount() {\n    window.addEventListener('hashchange', () => this.handleHashChange(), false);\n    if(this.state.firstLoad){\n      console.log('first app load')\n      this.loadUrlFiles();\n      this.setState({firstLoad:false});\n    }\n  }\n\n  loadUrlFiles(){\n    const params = new URLSearchParams(window.location.hash.split('#')[1]);\n\n    // get path to file(s) from urls\n    const fileUrls = params.getAll('file');\n    if (!fileUrls.length) return;\n\n    this.loadRemoteFiles(0, fileUrls);\n\n    utils.setFileHash(fileUrls);\n\n    // get node to display from url\n    let node;\n    const searchDCId = params.get('dcid');\n    if (searchDCId) {\n       node = API.retrieveNode(searchDCId, /* shouldCreateRemote */ true);\n     this.setState({curNode: node});\n      console.log(node)\n    }\n\n  }\n\n  /**\n   * Sets App state according to url parameters 'id' and 'file'. The param 'id'\n   * will cause the display node page to appear with the node of the specified\n   * id. The 'file' param followed by url to a file will cause that file to be\n   * loaded and parsed if it is one url to mcf or two 'file' params with one a\n   * url to a tmcf and the other a url to a csv file.\n   */\n  handleHashChange() {\n    const params = new URLSearchParams(window.location.hash.split('#')[1]);\n    // get node to display from url\n\n    let searchId = params.get('id');\n    let shouldCreateRemote = false;\n    if (!searchId) {\n      searchId = params.get('dcid');\n      shouldCreateRemote = true;\n    }\n\n    let node = null;\n    if (searchId) {\n       node = API.retrieveNode(searchId, shouldCreateRemote);\n    }\n    this.setState({curNode: node});\n\n    const err = params.get('error');\n    console.log(err)\n    let errMsg = '';\n    if( err === 'noLocalFiles'){\n      console.log('errMsg')\n       errMsg = 'Use dcid namespace if searching for remote node or '\n        + 'load a file to search for a local id.'\n    } else if(err){\n      errMsg = 'Error occured in search. Verify node you are trying to find.'\n    }\n    this.setState({searchErrMsg: errMsg});\n  }\n\n  /**\n   * Gets a remote file from an Array of urls at index i and appends the\n   * retrieved file to App state's fileList. This is a recursive method that\n   * calls itself to iterate through the entire Array of fileUrls.\n   * @param {number} i The index of the url to get from fileUrls array.\n   * @param {Array<string>} fileUrls The array of file urls to load and append\n   *     to App state's fileList.\n   */\n  loadRemoteFiles(i, fileUrls) {\n    if (i >= fileUrls.length) {\n      this.submitFileList();\n      return;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'blob';\n    xhr.open('GET', fileUrls[i]);\n    console.log('loading: ' + fileUrls[i]);\n    xhr.onload = () => {\n      console.log('finished loading');\n      console.log(xhr.response);\n      const fileUrl = new URL(fileUrls[i])\n      xhr.response.name=fileUrls[i];\n      console.log(xhr.response.name)\n      this.setState({fileList: this.state.fileList.concat(xhr.response)});\n      this.loadRemoteFiles(i+1, fileUrls);\n    };\n    xhr.send();\n  }\n\n  /**\n   * Passes App state's fileList array to the 'back-end' API to be parsed and\n   * the files loaded into memory.\n   */\n  submitFileList() {\n    this.setState({loading: (\n      <div>\n        <div className='loadingSpinner'></div>\n        <h2>...loading mcf...</h2>\n      </div>)});\n\n    API.readFileList(this.state.fileList)\n        .then( (subjList) => {\n          this.setState({subjNodes: subjList, loading: null})\n          this.handleHashChange();\n        });\n  }\n\n  /**\n   * Clear App state and calls the 'back-end' API clearFiles method.\n   */\n  onClearPress() {\n    this.setState({subjNodes: [], fileList: [], loading: null});\n    API.clearFiles();\n  }\n  /** Renders the browser by displaying a specific node or the homepage. */\n  render() {\n\n    let display;\n    if (this.state.curNode) {\n      display =  (\n      \t<DisplayNode node={this.state.curNode} />\n      );\n    } else{\n      display = (\n        <div className='Home'>\n        <h3>{this.state.searchErrMsg}</h3>\n        <div className='div-row'>\n\n          <div id='curFiles'>\n          <h3>Current Files:</h3>\n          <ul >{this.state.fileList.map( (file) =>\n            <li className='clickable' onClick={()=>utils.openFile(file.name)} key={file.name}>{file.name}</li>,\n          )}</ul>\n          <br></br>\n          <button onClick={() => this.onClearPress()} >Clear</button>\n          <br></br>\n          <h3>Subject Nodes:</h3>\n          <ul>{this.state.subjNodes.map( (dcid) =>\n            <li className='clickable' key={dcid} onClick={() => utils.goToId(dcid)}>{dcid}</li>,\n          )}</ul>\n          {this.state.loading}\n      </div>\n\n          <div id='uploadFiles'>\n            <h3>Upload one MCF file or one set of TMCF+CSV files to preview in Data Commons.</h3>\n            <div>\n          <input id=\"file-select\" onChange={ (event) =>{\n              this.setState({fileList: this.state.fileList.concat(Array.from(event.target.files))})\n            } }\n            type=\"file\" name=\"UploadFile\" accept=\".mcf,.tmcf,.csv\" required multiple />\n            <button onClick={() => this.submitFileList()} >Submit</button>\n            </div>\n          </div>\n              </div>\n        </div>\n      )\n    }\n\n    return (\n      <div className=\"App\">\n        <Header />\n        {display}\n      </div>\n\n    );\n  }\n}\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n"],"sourceRoot":""}