{"version":3,"sources":["back-end/utils.js","back-end/graph.js","back-end/parse-mcf.js","back-end/parse-tmcf.js","back-end/server-api.js","utils.js","TriplesTable.js","DisplayNode.js","Header.js","App.js","index.js"],"names":["API_ROOT","ERROR_MESSAGES","getRemotePropertyLabels","dcid","a","targetUrl","fetch","then","res","json","data","JSON","parse","payload","getRemotePropertyValues","label","isInverse","triples","in","out","getValueFromValueObj","valueObj","Error","value","Node","getNode","setDCID","existsInKG","doesExistsInKG","url","shouldReadLine","line","startsWith","length","id","this","localId","alreadyFetched","assertions","invAssertions","nodeHash","remote","mergeNode","absorbedNode","forEach","assert","src","push","invAssert","target","propLabels","valueList","val","isNode","source","Assertion","provenanceId","allLabels","createAssertionsFromLabels","outLabels","inLabels","dcidRef","localRef","includes","join","trim","existing","obj","property","provenance","Object","NAMESPACES","ParseMcf","fileName","prov","curNode","lineNum","errors","propValues","values","split","propValue","namespace","substring","indexOf","replace","parsedValues","nodeRef","ns","nodeId","localNodeHash","propLabel","parsePropValues","setCurNode","setCurNodeDCID","createAssertionsFromParsedValues","mcf","lines","parseLine","localNodes","keys","errMsgs","file","fileReader","FileReader","readAsText","Promise","rej","addEventListener","result","mcfParser","name","parseMcfStr","getArrowId","getEntityID","localIdMatch","match","getLocalIdFromEntityId","entityID","index","parsePropertyValues","csvRow","parsedValue","colName","fillTemplateFromRow","template","filledTemplate","csvToMCF","csvRows","mcfStrList","row","readCSVFile","csvFile","csv","fromString","console","log","readTMCFFile","tmcfFile","tmcfCSVToMCF","fileList","endsWith","mcfFile","readFile","ParseTMCF","retrieveNode","shouldCreateRemote","foundNode","isNodeObj","getElemId","setExistsInKG","fileHash","goToId","window","location","hash","openFile","fileUrl","open","getMissingVal","API","elemId","className","onClick","utils","getRef","onProvClick","getRowFromTriple","missingVal","provId","provName","provElem","rowClassName","provNames","pop","key","asserts","tripleRows","tripleRow","TriplesTable","props","state","tableRows","loading","prevProps","setState","getTripleRows","inverse","rows","tableHeaders","Component","COLOR_LEGEND","DisplayNode","ref","invAsserts","fetching","setNodeData","node","fetchRemoteData","Header","event","keyCode","type","onKeyUp","handleSearch","placeholder","App","subjNodes","firstLoad","searchErrMsg","parsingErrs","handleHashChange","loadUrlFiles","params","URLSearchParams","fileUrls","getAll","loadRemoteFiles","fileUrlList","searchId","get","err","errMsg","i","submitFileList","xhr","XMLHttpRequest","responseType","onload","response","concat","send","display","map","onClearPress","msg","onChange","Array","from","files","accept","required","multiple","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"6RAqBMA,EAAW,8BAEXC,EAEkB,0BAFlBA,EAGc,wCAHdA,EAIiB,+CAJjBA,EAKoB,gCALpBA,EAMe,uDANfA,EAQI,iEARJA,EASgB,uDAThBA,EAUiB,2CAVjBA,EAWiB,yBAXjBA,EAYkB,yB,SASTC,E,8EAAf,WAAuCC,GAAvC,eAAAC,EAAA,6DACQC,EAAYL,EAAW,+BAAiCG,EADhE,kBAESG,MAAMD,GACRE,MAAK,SAACC,GAAD,OAASA,EAAIC,UAClBF,MAAK,SAACG,GAAD,OAAUC,KAAKC,MAAMF,EAAKG,SAASV,OAJ/C,4C,+BAiBeW,E,kFAAf,WAAuCX,EAAMY,EAAOC,GAApD,eAAAZ,EAAA,6DAEQC,EACDL,EAAW,yCAA2CG,EACtD,aAAeY,EAAQ,eAHVC,EAAY,KAAO,OADvC,kBAMSV,MAAMD,GACRE,MAAK,SAACC,GAAD,OAASA,EAAIC,UAClBF,MAAK,SAACG,GAAD,OAAUC,KAAKC,MAAMF,EAAKG,SAASV,MACxCI,MAAK,SAACU,GAAD,OAAaD,EAAYC,EAAQC,GAAKD,EAAQE,QAT1D,4C,sBAqBA,SAASC,EAAqBC,GAC5B,KAAM,SAAUA,MAAY,UAAWA,GACrC,MAAM,IAAIC,MACN,qEACAD,GAGN,GAAI,SAAUA,EAAU,CACtB,IAAME,EAAQC,EAAKC,QAAQ,QAAUJ,EAASlB,MAG9C,OAFAoB,EAAMG,QAAQL,EAASlB,MACvBoB,EAAMI,YAAa,EACZJ,EAET,OAAOF,EAASE,M,SAUHK,E,8EAAf,WAA8BzB,GAA9B,eAAAC,EAAA,6DACQyB,EAAM7B,EAAW,uBAAyBG,EAAO,WADzD,kBAESG,MAAMuB,GACRtB,MAAK,SAACC,GAAD,OAASA,EAAIC,UAClBF,MAAK,SAACG,GAAD,QAAUC,KAAKC,MAAMF,EAAKG,SAASV,OAJ/C,4C,sBAaA,SAAS2B,EAAeC,GACtB,OAAIA,EAAKC,WAAW,OAAyB,IAAhBD,EAAKE,SAAgBF,EAAKC,WAAW,K,IC3F9DR,E,WA6CJ,WAAYU,GAAK,oBACfC,KAAKC,QAAUF,EAAGF,WAAW,MAAQE,EAAK,KAC1CC,KAAKhC,KAAO,KAEZgC,KAAKE,gBAAiB,EACtBF,KAAKR,YAAa,EAElBQ,KAAKG,WAAa,GAClBH,KAAKI,cAAgB,GAErBf,EAAKgB,SAASN,GAAMC,K,oDAkCdhC,GACN,GAAIgC,KAAKhC,MAAQgC,KAAKhC,OAASA,EAC7B,OAAO,EAGT,IAAMsC,EAASjB,EAAKgB,SAAS,QAAUrC,GAMvC,OALIsC,GAAUA,IAAWN,MACvBA,KAAKO,UAAUD,GAEjBN,KAAKhC,KAAOA,EACZqB,EAAKgB,SAAS,QAAUrC,GAAQgC,MACzB,I,gCAUCQ,GAAe,IAAD,OAClBR,KAAKC,UAAYO,EAAaP,UAIlCO,EAAaL,WAAWM,SAAQ,SAACC,GAC/BA,EAAOC,IAAM,EACb,EAAKR,WAAWS,KAAKF,MAGvBF,EAAaJ,cAAcK,SAAQ,SAACI,GAClCA,EAAUC,OAAS,EACnB,EAAKV,cAAcQ,KAAKC,S,mJAQrBb,KAAKhC,OAAQgC,KAAKR,W,iEAGCC,EAAeO,KAAKhC,M,OAA5CgC,KAAKR,W,uMAe0BuB,EAAYlC,G,gGACvBkC,G,gHAATnC,E,iBACHD,EAAwB,EAAKX,KAAMY,EAAOC,GAC3CT,MAAK,SAAC4C,GACL,IAAKA,EACH,MAAM,IAAI7B,MAAM,gCAAkC,EAAKnB,KACvC,WAAaY,GAG/BoC,EAAUP,SAAQ,SAACvB,GACjB,IAAM+B,EAAMhC,EAAqBC,GAEjC,GAAIL,IAAcQ,EAAK6B,OAAOD,GAC5B,MAAM,IAAI9B,MACN,iDAGN,IAAMgC,EAAStC,EAAYoC,EAAM,EAC3BH,EAASjC,EAAY,EAAOoC,EAI7B5B,EAAK6B,OAAOD,IAASA,EAAIf,gBAC5B,IAAIkB,EAAUD,EAAQvC,EAAOkC,EAAQ5B,EAASmC,oB,2hBAYtDrB,KAAKE,gBAAmBF,KAAKhC,K,iEAI3BD,EAAwBiC,KAAKhC,MAAMI,KAAnC,uCAAwC,WAAOkD,GAAP,SAAArD,EAAA,sEACtC,EAAKsD,2BAA2BD,EAAUE,WAC5B,GAFwB,uBAGtC,EAAKD,2BAA2BD,EAAUG,UAC5B,GAJwB,2CAAxC,uD,OAMNzB,KAAKE,gBAAiB,E,qIAWtB,IAAMwB,EAAU1B,KAAKhC,KAAOgC,KAAKhC,KAAO,GACpC2D,EAAW,GAKf,OAHI3B,KAAKC,UAAYD,KAAKC,QAAQ2B,SAAS,UACzCD,EAAW,IAAM3B,KAAKC,QAAU,KAE3B,CAACyB,EAASC,GAAUE,KAAK,KAAKC,U,+BAjJxB/B,GACb,IAAMgC,EAAW1C,EAAKgB,SAASN,GAC/B,OAAOgC,GAAsB,IAAI1C,EAAKU,K,6BAQ1BiC,GACZ,OAAOA,aAAe3C,M,KA0I1BA,EAAKgB,SAAW,G,IAGVe,EA8BJ,WAAYT,EAAKsB,EAAUnB,EAAQoB,GAAa,oBAC9ClC,KAAKW,IAAMA,EACXX,KAAKiC,SAAWA,EAChBjC,KAAKkC,WAAaA,EAClBlC,KAAKc,OAASA,EAEdH,EAAIR,WAAWS,KAAKZ,MAEhBc,aAAkBqB,QACpBrB,EAAOV,cAAcQ,KAAKZ,OCrQ1BoC,EAAa,CACjB,EAAK,IACL,OAAU,OACV,IAAO,OACP,KAAQ,QAIJC,E,WAiCJ,WAAYC,GAAW,oBACrBtC,KAAKuC,KAAOD,EACZtC,KAAKwC,QAAU,KACfxC,KAAKyC,SAAW,EAChBzC,KAAK0C,OAAS,G,4DAYAC,GACd,IAD0B,EACpBC,EAAS,GADW,cAGFD,EAAWE,MAAM,kCAHf,IAG1B,2BAA2E,CAAC,IAAjEC,EAAgE,QACnEC,EAAYD,EAAUD,MAAM,KAAK,GAAGf,OAC1C,GAAIiB,KAAaX,EACfQ,EAAOhC,KAAK,CACV,GAAMmC,EACN,IAAOD,EAAUE,UAAUF,EAAUG,QAAQ,KAAO,GAAGnB,aAEpD,IAAIgB,EAAUD,MAAM,KAAK/C,OAAS,IAC7BiD,EAAUlD,WAAW,KAE/B,OADAG,KAAK0C,OAAO9B,KAAK,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM,2BACpC,GAGPgD,EAAOhC,KAAKkC,EAAUI,QAAQ,qBAAsB,SAhB9B,8BAmB1B,OAAON,I,iCAcEO,GACT,GAA4B,IAAxBA,EAAarD,OAAjB,CAOA,IAAIsD,EAAUD,EAAa,GACvBE,EAAK,GAIT,GAAIF,EAAa,aAAchB,OAAQ,CAErC,GAAW,UADXkB,EAAKF,EAAa,GAAb,IAOH,YAFAnD,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,IAJ9BuF,GAAU,IACVD,EAAUD,EAAa,GAAb,IAQd,IAAMG,EAAS,KAAOD,EAAKD,EAC3BpD,KAAKwC,QAAUnD,EAAKC,QAAQgE,GAEjB,UAAPD,GACFrD,KAAKwC,QAAQjD,QAAQ6D,GACrBf,EAASkB,cAAcF,EAAKD,GAAWpD,KAAKwC,SAE5CH,EAASkB,cAAcD,GAAUtD,KAAKwC,aA9BtCxC,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,M,qCAuCnBqF,GACRnD,KAAKwC,QAKkB,IAAxBW,EAAarD,OAKc,kBAApBqD,EAAa,GAMnBnD,KAAKwC,QAAQjD,QAAQ4D,EAAa,KACrCnD,KAAK0C,OAAO9B,KAAK,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,IAN3CkC,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,IAN9BkC,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,IAN9BkC,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,M,uDA6BD0F,EAAWL,GAC1C,GAAKnD,KAAKwC,QAAV,CADwD,oBAMtCW,GANsC,IAMxD,2BAAgC,CAAC,IAAtBlC,EAAqB,QAC1BH,EAASG,EACTA,aAAekB,SACjBrB,EAASzB,EAAKC,QAAQ8C,EAAWnB,EAAG,IAAU,IAAMA,EAAG,KACzB,SAA1BmB,EAAWnB,EAAG,MACXH,EAAOvB,QAAQ0B,EAAG,MACrBjB,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,MAIpC,IAAIsD,EAAUpB,KAAKwC,QAASgB,EAAW1C,EAAQd,KAAKuC,OAjBE,oCAEtDvC,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,M,gCA2BxB8B,GAGR,GAAKD,EAFLC,EAAOA,EAAKkC,QAMZ,GAAKlC,EAAKgC,SAAS,KAAnB,CAMA,IAAM4B,EAAY5D,EAAKiD,MAAM,IAAK,GAAG,GAAGf,OAClCa,EAAa/C,EAAKoD,UAAUpD,EAAKqD,QAAQ,KAAO,GAEtD,GAAKO,EAKL,GAAKb,EAAL,CAMA,IAAMQ,EAAenD,KAAKyD,gBAAgBd,GAE1C,OAAQa,GACN,IAAK,OACHxD,KAAK0D,WAAWP,GAChB,MAEF,IAAK,OACHnD,KAAK2D,eAAeR,GACpB,MAEF,QACEnD,KAAK4D,iCAAiCJ,EAAWL,SAjBnDnD,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,SAN9BkC,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,SAV9BkC,KAAK0C,OAAO9B,KACR,CAACZ,KAAKyC,QAASzC,KAAKJ,KAAM9B,M,kCAyCtB+F,GAAM,IAAD,OACTC,EAAQD,EAAIhB,MAAM,MASxB,OARA7C,KAAKyC,QAAU,EAEfqB,EAAMrD,SAAQ,SAACb,GACb,EAAKA,KAAOA,EACZ,EAAKmE,UAAUnE,GACf,EAAK6C,aAGA,CACLuB,WAAY7B,OAAO8B,KAAK5B,EAASkB,eACjCW,QAASlE,KAAK0C,W,gCAUFyB,GACd,IAAMC,EAAa,IAAIC,WAGvB,OAFAD,EAAWE,WAAWH,GAEf,IAAII,SAAQ,SAAClG,EAAKmG,GACvBJ,EAAWK,iBAAiB,WAAW,SAACC,GACtC,IAAMC,EAAY,IAAItC,EAAS8B,EAAKS,MACpCvG,EAAIsG,EAAUE,YAAYT,EAAWM,YAEvCN,EAAWK,iBAAiB,QAASD,U,KAK3CnC,EAASkB,cAAgB,G,YCrRzB,SAASuB,EAAWhC,GAClB,OAAIA,EAAUlB,SAAS,MACdkB,EAAUD,MAAM,MAAM,GAExB,KAQT,SAASkC,EAAYnF,GACnB,IAAMoF,EAAepF,EAAKqF,MAAM,gBAChC,OAAID,EACKA,EAAa,GAEf,KAWT,SAASE,EAAuBC,EAAUC,GACxC,OAAID,EACKA,EAASjC,QAAQ,KAAM,KAAKA,QAAQ,KAAM,IAAM,KAAOkC,EAEzD,KAiBT,SAASC,EAAoB1C,EAAY2C,EAAQF,GAC/C,IADsD,EAChDjC,EAAe,GADiC,cAG9BR,EAAWE,MAAM,MAHa,IAGtD,2BAA+C,CAAC,IAArCC,EAAoC,QACzCyC,EAAczC,EAEZqC,EAAWJ,EAAYjC,GAI7B,GAAIqC,EAAU,CACZ,IAAMlF,EAAU,KAAOiF,EAAuBC,EAAUC,GACxDG,EAAcA,EAAYrC,QAAQiC,EAAUlF,OACvC,CAEL,IAAMuF,EAAUV,EAAWhC,GAC3ByC,EAAcA,EAAYrC,QAAQ,eAAgBoC,EAAOE,IAE3DrC,EAAavC,KAAK2E,IAlBkC,8BAoBtD,OAAOpC,EAAatB,KAAK,KAa3B,SAAS4D,EAAoBC,EAAUJ,EAAQF,GAC7C,IADoD,EAC9CO,EAAiB,GAD6B,cAEjCD,EAAS7C,MAAM,OAFkB,IAEpD,2BAAyC,CAAC,IAA/BjD,EAA8B,QACvC,GAAKA,EAAKkC,QAKV,GAAKnC,EAAeC,GAApB,CAIA,IAAM4D,EAAY5D,EAAKiD,MAAM,KAAK,GAAGf,OAG/Ba,EAAa/C,EAAKsD,QAAQM,EAAY,IAAK,IAAI1B,OAErD,GAAkB,SAAd0B,EAAsB,CACxB,GAAIb,EAAWf,SAAS,KACtB,MAAM,IAAIzC,MAAM,iDAElB,IAAIY,EAAK4C,EACHwC,EAAWJ,EAAYpC,GACzBwC,IACFpF,EAAKmF,EAAuBC,EAAUC,IAExCO,EAAe/E,KAAK4C,EAAY,KAAOzD,OAClC,CACL,IAAMoD,EAAekC,EAAoB1C,EAAY2C,EAAQF,GAC7DO,EAAe/E,KAAK4C,EAAY,KAAOL,UAzBvCwC,EAAe/E,KAAK,KAJ4B,8BAgCpD,OAAO+E,EAAe9D,KAAK,MAY7B,SAAS+D,EAASF,EAAUG,GAC1B,IADmC,EAC/BT,EAAQ,EACNU,EAAa,GAFgB,cAGjBD,GAHiB,IAGnC,2BAA2B,CAAC,IAAjBE,EAAgB,QACzBD,EAAWlF,KAAK6E,EAAoBC,EAAUK,EAAKX,IACnDA,GAAS,GALwB,8BAOnC,OAAOU,EAAWjE,KAAK,M,SAYVmE,E,gFAAf,WAA2BN,EAAUO,GAArC,eAAAhI,EAAA,6DACQmG,EAAa,IAAIC,YACZC,WAAW2B,GAFxB,kBAGS,IAAI1B,SAAQ,SAAClG,EAAKmG,GACvBJ,EAAWK,iBAAiB,WAAW,SAACC,GACtCwB,IAAMC,WAAW/B,EAAWM,QAAQtG,MAAK,SAACyH,GACxCO,QAAQC,IAAI,YAAcJ,EAAQrB,MAClC,IAAMf,EAAM+B,EAASF,EAAUG,GAC/BxH,EAAIwF,SAGRO,EAAWK,iBAAiB,QAASD,OAXzC,4C,+BAoBe8B,E,8EAAf,WAA4BC,GAA5B,eAAAtI,EAAA,6DACQmG,EAAa,IAAIC,YACZC,WAAWiC,GAFxB,kBAGS,IAAIhC,SAAQ,SAAClG,EAAKmG,GACvBJ,EAAWK,iBAAiB,WACxB,SAACC,GACCrG,EAAI+F,EAAWM,WAErBN,EAAWK,iBAAiB,QAASD,OARzC,4C,+BAkBegC,E,gFAAf,WAA4BD,EAAUN,GAAtC,SAAAhI,EAAA,+EACSqI,EAAaC,GAAUnI,MAAK,SAACsH,GAAD,OACjCM,EAAYN,EAAUO,OAF1B,4C,kECvMA,WAA4BQ,GAA5B,yBAAAxI,EAAA,oEAIqBwI,GAJrB,IAIE,4BAAWtC,EAAkB,SAClBS,KAAK8B,SAAS,SACrBH,EAAWpC,EACFA,EAAKS,KAAK8B,SAAS,QAC5BT,EAAU9B,EAEVwC,EAAUxC,EAVhB,kCAcMwC,EAdN,yCAeWtE,EAASuE,SAASD,IAf7B,WAkBMJ,IAAYN,EAlBlB,yCAmBWY,EAAuBN,EAAUN,GAAS7H,MAAK,SAACyF,GAGrD,OAFAuC,QAAQC,IAAIxC,GACM,IAAIxB,EAASkE,EAAS3B,KAAO,IAAMqB,EAAQrB,MAC5CC,YAAYhB,OAtBnC,gCAyBS,CAAC,QAAW,GAAI,WAAc,KAzBvC,4C,sBAiCA,SAASiD,EAAa/G,EAAIgH,GACxB,IAAMC,EAAY3H,EAAKC,QAAQS,GAQ/B,OAPIgH,GACFC,EAAUzH,QAAQQ,EAAGmD,QAAQ,QAAS,KAGxCkD,QAAQC,IAAIhE,EAASkB,cAAcxD,IACnCqG,QAAQC,IAAI,YACZD,QAAQC,IAAIW,GACLA,EAGT,SAASC,EAAUjF,GACjB,OAAO3C,EAAK6B,OAAOc,G,SAGNkF,G,iFAAf,WAAyBpG,GAAzB,SAAA7C,EAAA,yDACO6C,EADP,yCAEW,MAFX,WAIMA,EAAOtB,WAJb,yCAKW,QALX,gCAQSsB,EAAOqG,gBAAgB/I,MAAK,WACjC,OAAI0C,EAAOtB,WACF,QAGJsB,EAAO9C,MAAQ8C,EAAOb,SACvBa,EAAOb,WAAWoC,EAASkB,cACtB,SAGJzC,EAAO9C,MAAU8C,EAAOb,WAAWoC,EAASkB,cAG1C,MAFE,aAnBb,4C,sBC3DA,IAAI6D,GAAW,IAMf,SAASC,GAAOtH,GACVA,EAAG6B,SAAS,KACd0F,OAAOC,SAASC,KAAOJ,GAAW,OAASrH,EAE3CuH,OAAOC,SAASC,KAAOJ,GAAW,YAAcrH,EA2BpD,SAAS0H,GAASC,GAAWJ,OAAOK,KAAKD,G,SCZ1BE,G,iFAAf,WAA6B9G,GAA7B,eAAA7C,EAAA,0DACM4J,EAAc/G,GADpB,gCAEyB+G,GAAc/G,GAFvC,cAEUgH,EAFV,yBAGY,4BAAI,uBAAG/H,GAAM+H,EAAQC,UAAY,YAAYC,QACnC,kBAAMC,GAAanH,EAAOb,SAAWa,EAAO9C,QAC1D8C,EAAOoH,YALf,gCAOU,4BAAMpH,IAPhB,4C,sBASA,SAASqH,GAAYL,EAAQvF,GACxBuF,EACDG,GAAa1F,GAEb0F,GAAe1F,G,SAWJ6F,G,qFAAf,WAAgC1H,EAAQ7B,EAAWuG,GAAnD,iCAAAnH,EAAA,6DACQoK,EAAaxJ,EAAY6B,EAAOC,IAAMD,EAAOI,OADrD,SAEoB8G,GAAcS,GAFlC,OASE,GAPMpH,EAFR,OAKMqH,EAAS,QACTC,EAAW7H,EAAOwB,WAClBsG,EAAY,uBAAGzI,GAAIuI,EAAQP,UAAU,YACtCC,QAAS,kBAAMG,GAAYG,EAAQ5H,EAAOwB,cAAcqG,GACxDA,EAAS1I,WAAW,SAAS,CAC9B4I,EAAe,OACfH,EAAS,GACHI,EAAY,GAHY,cAIPH,EAAS1F,MAAM,MAJR,IAI9B,2BAAWP,EAAiC,QAC1CoG,EAAU9H,KAAK0B,EAASO,MAAM,KAAK8F,OALP,8BAO9BH,EAAY,uBAAGzI,GAAIuI,EAAQP,UAAU,YAClCC,QAAS,kBAAMG,GAAYG,EAAQ5H,EAAOwB,cAAcwG,EAAU,IAElEA,EAAU5I,OAAS,IACpB0I,EAAY,6BACV,uBAAGzI,GAAIuI,EAAQP,UAAU,YACtBC,QAAS,kBAAMG,GAAYG,EAAQ5H,EAAOwB,WAAWW,MAAM,KAAK,MAAM6F,EAAU,IAClF,+BAjEkB,QAkEhB,uBAAG3I,GAAIuI,EAAQP,UAAU,YACtBC,QAAS,kBAAMG,GAAYG,EAAQ5H,EAAOwB,WAAWW,MAAM,KAAK,MAAM6F,EAAU,MAzB9F,yBA8BI,wBAAIX,UAAWU,EAAcG,IAAKlI,EAAOuB,SAAWmD,GAClD,4BAAK1E,EAAOuB,UACXhB,EACD,4BAAKuH,KAjCX,4C,oEAgDE,WAA6BK,EAAShK,GAAtC,yBAAAZ,EAAA,sDACQ6K,EAAa,GACf1D,EAAQ,EAFd,cAGuByD,GAHvB,gEAGanI,EAHb,iBAI4B0H,GAAiB1H,EAAQ7B,EAAWuG,GAJhE,OAIU2D,EAJV,OAKID,EAAWlI,KAAKmI,GAChB3D,GAAS,EANb,wKAQS0D,GART,iE,sBAyBO,IAAME,GAAb,kDAEE,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IAEDC,MAAQ,CACXC,UAAY,KACZC,SAAU,GALK,EAFrB,+DAgBqBC,GAAY,IAAD,OACxBA,EAAUvK,UAAYkB,KAAKiJ,MAAMnK,UACnCkB,KAAKsJ,SAAS,CAACF,SAAU,I,8CACzBG,CAAcvJ,KAAKiJ,MAAMnK,QAASkB,KAAKiJ,MAAMO,SAASpL,MAAK,SAACqL,GAC1D,EAAKH,SAAS,CAACH,UAAYM,EAAML,SAAU,UApBnD,+BA2BI,GAAIpJ,KAAKkJ,MAAME,QACb,OAAO,KAET,IAAMM,EAA+B1J,KAAKiJ,MAAMO,QA1CxC,4BAAI,wCACV,sCACM,2CAGF,4BAAI,wCACV,sCACM,2CAqCR,OACE,+BACE,+BACGE,GAEH,+BAAQ1J,KAAKkJ,MAAMC,gBArCzB,GAAkCQ,aCnH9BC,GACD,6BAAK,uBAAG7B,UAAY,UAAf,KAEN,uBAAGA,UAAU,SAAShI,GAAG,QAAzB,sCACC,uBAAGgI,UAAY,UAAf,KAED,uBAAGA,UAAU,SAAShI,GAAG,UAAzB,iDACC,uBAAGgI,UAAY,UAAf,KAED,uBAAGA,UAAU,SAAShI,GAAG,UAAzB,mDACC,uBAAGgI,UAAY,UAAf,KAED,uBAAGA,UAAU,SAAShI,GAAG,OAAzB,wDACC,uBAAGgI,UAAY,UAAf,MAKC8B,G,kDAEJ,WAAYZ,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,CACXY,IAAM,KACNjB,QAAU,GACVkB,WAAa,GACbC,UAAW,GAEb5D,QAAQC,IAAI,uBARK,E,gEAYGrG,KAAKiK,gB,yCAORZ,GACbA,EAAUa,OAASlK,KAAKiJ,MAAMiB,MAChClK,KAAKiK,gB,oCAQM,IAAD,OACZ7D,QAAQC,IAAIrG,KAAKiJ,MAAMiB,MAEvB,IAAM1H,EAAUxC,KAAKiJ,MAAMiB,KAC3BlK,KAAKsJ,SAAS,CACZQ,IAAMtH,EAAQ0F,SACd8B,UAAW,EACXnB,QAAU,GACVkB,WAAa,KAGflC,GAAcrF,GAASpE,MAAK,SAAC0J,GAAD,OAAY,EAAKwB,SAAS,CAACxB,OAASA,OAEhEtF,EAAQ2H,kBAAkB/L,MAAK,WAC7B,EAAKkL,SAAS,CACZT,QAAUrG,EAAQrC,WAClB4J,WAAavH,EAAQpC,cACrB4J,UAAW,S,+BAOf,IAAIA,EAQJ,OAPIhK,KAAKkJ,MAAMc,WACbA,EAAY,yBAAKjC,UAAY,WAAU,6BAEjC,yBAAKA,UAAU,mBACT,wDAIZ,6BACG6B,GACD,6BACA,wBAAI7B,UAAU,UAAd,uBACA,wBAAIA,UAAU,SAAShI,GAAIC,KAAKkJ,MAAMpB,QAAS9H,KAAKkJ,MAAMY,KAC5D,6BACCE,EACD,yBAAKjC,UAAU,QACb,wBAAIhI,GAAG,SAASgI,UAAU,UAA1B,mBACA,uBAAGA,UAAU,UAAb,6BACE,6BACF,kBAAC,GAAD,CAAcjJ,QAASkB,KAAKkJ,MAAML,QAASW,SAAS,IACpD,6BACA,wBAAIzJ,GAAG,SAASgI,UAAU,UAA1B,wCACA,uBAAGA,UAAU,UAAb,6BACE,6BAEF,kBAAC,GAAD,CAAcjJ,QAASkB,KAAKkJ,MAAMa,WAAYP,SAChD,U,GAlFoBG,aClBpBS,G,2KAKSC,GHEf,IAAkBtK,EGDQ,KAAlBsK,EAAMC,WHCIvK,EGAGsK,EAAMvJ,OAAO1B,OHCzBwC,SAAS,KACd0F,OAAOC,SAASC,KAAOJ,GAAW,WAAarH,EAE/CuH,OAAOC,SAASC,KAAOJ,GAAW,gBAAkBrH,K,+BGCpD,OACE,yBAAKgI,UAAU,UACb,4BAAQC,QAAW,kBHKzB5B,QAAQC,IAAIe,SACZE,OAAOC,SAASC,KAAOJ,MGNjB,eACA,2BAAOmD,KAAK,SAASC,QAASxK,KAAKyK,aACjCC,YAAY,+D,GAhBDf,aCuONgB,G,kDApOb,WAAY1B,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,CACX0B,UAAY,GACZpI,QAAU,KACViE,SAAW,GACX2C,QAAU,KACVhC,SAAW,GACXyD,WAAY,EACZC,aAAe,GACfC,YAAc,IAVC,E,gEAcE,IAAD,OAClBzD,OAAO7C,iBAAiB,cAAc,kBAAM,EAAKuG,sBAAoB,GACjEhL,KAAKkJ,MAAM2B,YACbzE,QAAQC,IAAI,kBACZrG,KAAKiL,eACLjL,KAAKsJ,SAAS,CAACuB,WAAY,O,qCAK7B,IAAMK,EAAS,IAAIC,gBAAgB7D,OAAOC,SAASC,KAAK3E,MAAM,KAAK,IAG7DuI,EAAWF,EAAOG,OAAO,QAE/B,GAAID,EAAStL,OAEXE,KAAKsL,gBAAgB,EAAGF,GJX9B,SAAqBG,GACnBnE,GAAW,IADqB,oBAEVmE,GAFU,IAEhC,2BAAmC,CAAC,IAAzB7D,EAAwB,QACjCN,IAAY,SAAWM,GAHO,+BIa5BO,CAAkBmD,OACb,CAEL,IAAIlB,EACEsB,EAAWN,EAAOO,IAAI,MAC5BrF,QAAQC,IAAImF,GACRA,IACFtB,EAAOrC,EAAiB2D,GAAmC,GAC3DxL,KAAKsJ,SAAS,CAAC9G,QAAU0H,IACzB9D,QAAQC,IAAI6D,O,yCAahB,IAAMgB,EAAS,IAAIC,gBAAgB7D,OAAOC,SAASC,KAAK3E,MAAM,KAAK,IAG/DS,EAAS4H,EAAOO,IAAI,MAEpBvB,EAAO,KAKX,GAJI5G,IACF4G,EAAOrC,EAAiBvE,GAAQ,KAG7BA,EAAQ,CACX,IAAIkI,EAAWN,EAAOO,IAAI,UAE1BvB,EAAO,KACHsB,IACFtB,EAAOrC,EAAiB2D,GAAU,IAGtCxL,KAAKsJ,SAAS,CAAC9G,QAAU0H,IAEzB,IAAMwB,EAAMR,EAAOO,IAAI,UACvBrF,QAAQC,IAAIqF,GACZ,IAAIC,EAAS,GACD,iBAARD,GACFtF,QAAQC,IAAI,UACZsF,EAAS,4FAEAD,IACTC,EAAS,gEAEX3L,KAAKsJ,SAAS,CAACwB,aAAea,M,sCAWhBC,EAAGR,GAAW,IAAD,OAC3B,GAAIQ,GAAKR,EAAStL,OAChBE,KAAK6L,qBADP,CAIA,IAAMC,EAAM,IAAIC,eAChBD,EAAIE,aAAe,OACnBF,EAAInE,KAAK,MAAOyD,EAASQ,IACzBxF,QAAQC,IAAI,YAAc+E,EAASQ,IACnCE,EAAIG,OAAS,WACX7F,QAAQC,IAAI,oBACZD,QAAQC,IAAIyF,EAAII,UAChBJ,EAAII,SAAStH,KAAOwG,EAASQ,GAC7BxF,QAAQC,IAAIyF,EAAII,SAAStH,MACxB,EAAK0E,SACF,CAAC7C,SAAW,EAAKyC,MAAMzC,SAAS0F,OAAOL,EAAII,YAC/C,EAAKZ,gBAAgBM,EAAI,EAAGR,IAE9BU,EAAIM,U,uCAOY,IAAD,OACfpM,KAAKsJ,SAAS,CACZF,QACI,6BAAK,yBAAKrB,UAAY,mBAExB,oD,2CAGJF,CAAiB7H,KAAKkJ,MAAMzC,UACvBrI,MAAM,SAACC,GACN+H,QAAQC,IAAIhI,GACZ,EAAKiL,SAAS,CAACyB,YAAa1M,EAAG,QAAauM,UAAWvM,EAAG,WAAgB+K,QAAS,OACnF,EAAK4B,wB,qCAQXhL,KAAKsJ,SAAS,CAACsB,UAAW,GAAInE,SAAU,GAAI2C,QAAS,OLhHvD/J,EAAKgB,SAAW,GAChBgC,EAASkB,cAAgB,GKiH3B+D,OAAOC,SAASC,KAAO,M,+BAKX,IAEJ6E,EAFG,OAuEP,OAnEEA,EADErM,KAAKkJ,MAAM1G,QAEZ,kBAAC,GAAD,CAAa0H,KAAMlK,KAAKkJ,MAAM1G,UAG7B,yBAAKuF,UAAU,QACf,4BAAK/H,KAAKkJ,MAAM4B,cAChB,yBAAK/C,UAAU,WAEb,yBAAKhI,GAAG,YACR,8CACA,4BAAMC,KAAKkJ,MAAMzC,SAAS6F,KAAK,SAACnI,GAAD,OAC7B,wBAAI4D,UAAU,YAAYC,QAAS,kBAAIC,GAAe9D,EAAKS,OAAOgE,IAAKzE,EAAKS,MAAOT,EAAKS,UAE1F,6BACA,4BAAQoD,QAAS,kBAAM,EAAKuE,iBAA5B,SACA,6BACCvM,KAAKkJ,MAAM6B,YAAYjL,OAEpB,6BACA,+CACA,+BACE,+BACA,4BACE,wBAAIC,GAAG,cAAP,YACA,wBAAIA,GAAG,cAAP,QACA,wBAAIA,GAAG,cAAP,mBAEF,+BAAQC,KAAKkJ,MAAM6B,YAAYuB,KAAK,SAACE,GAAD,OAClC,wBAAI5D,IAAK4D,EAAI,IACX,4BAAKA,EAAI,IACP,4BAAKA,EAAI,IACP,4BAAKA,EAAI,WAQrB,6BACA,8CACF,4BAAKxM,KAAKkJ,MAAM0B,UAAU0B,KAAK,SAACtO,GAAD,OAC7B,wBAAI+J,UAAU,YAAYa,IAAK5K,EAAMgK,QAAS,kBAAMC,GAAajK,KAAQA,QAI1EgC,KAAKkJ,MAAME,SAGZ,yBAAKrJ,GAAG,eACN,4GACA,6BACF,2BAAOA,GAAG,cAAc0M,SAC5B,SAACpC,GACC,EAAKf,SAAS,CACZ7C,SAAW,EAAKyC,MAAMzC,SAAS0F,OAAOO,MAAMC,KAAKtC,EAAMvJ,OAAO8L,WAG5DrC,KAAK,OAAO3F,KAAK,aAAaiI,OAAO,kBAAkBC,UAAQ,EAACC,UAAQ,IACxE,4BAAQ/E,QAAS,kBAAM,EAAK6D,mBAA5B,cASN,yBAAK9D,UAAU,OACb,kBAAC,GAAD,MACCsE,O,GA/NS1C,aCFlBqD,IAASC,OACL,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEFC,SAASC,eAAe,U","file":"static/js/main.e42bae49.chunk.js","sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Module contains helper functions for api calls to data commons as well as\n * helper functions for parsing file to create local knowledge graph.\n */\n\nimport {Node} from './graph.js';\nconst API_ROOT = 'https://api.datacommons.org';\n\nconst ERROR_MESSAGES =\n    {\n      'curNode-length': 'error in declaring node',\n      'curNode-ns': 'invalid namespace in node declaration',\n      'setDCID-noCur': 'current node must be set before setting dcid',\n      'setDCID-multiple': 'a node can only have one dcid',\n      'setDCID-ref': 'dcid property must be a string, not a node reference',\n      'setDCID':\n          'cannot set dcid for current node; check if dcid is already set',\n      'assert-noCur': 'current node must be set before declaring properties',\n      'parse-noColon': 'missing \\':\\', incorrect mcf triple format',\n      'parse-noLabel': 'missing property label',\n      'parse-noValues': 'missing property value',\n    };\n\n/**\n * Gets all property labels of the given dcid that are in the DC KG.\n *\n * @param {string} dcid The dcid of the node to find property labels for.\n * @return {Object} An object containing both 'in' and 'out' property labels.\n */\nasync function getRemotePropertyLabels(dcid) {\n  const targetUrl = API_ROOT + '/node/property-labels?dcids=' + dcid;\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid]);\n}\n\n/**\n * Gets all property values containing the given dcid, property label, and\n * direction.\n *\n * @param {string} dcid The dcid of the node to find property value for.\n * @param {string} label The property label to query for.\n * @param {boolean} isInverse Direction of property label, false indicates\n *     an outgoing label, true is an incoming label.\n * @return {Object} An object containing all found values matching the query.\n */\nasync function getRemotePropertyValues(dcid, label, isInverse) {\n  const direction = isInverse ? 'in' : 'out';\n  const targetUrl =\n      (API_ROOT + '/node/property-values?limit=500&dcids=' + dcid +\n       '&property=' + label + '&direction=' + direction);\n\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid])\n      .then((triples) => isInverse ? triples.in : triples.out);\n}\n\n/**\n * Parses an Object returned from the DC REST get_values API to create a Node\n * object from the value's dcid or to return the string value that the object\n * holds.\n *\n * @param {Object} valueObj An object returned from DC REST get_values API.\n * @return {Node | string} The created Node if the value object has a dcid,\n *     otherwise the string of the value.\n */\nfunction getValueFromValueObj(valueObj) {\n  if (!('dcid' in valueObj || 'value' in valueObj)) {\n    throw new Error(\n        'ERROR: DC API returned an object with no \"dcid\" or \"value\" field: ' +\n        valueObj);\n  }\n\n  if ('dcid' in valueObj) {\n    const value = Node.getNode('dcid:' + valueObj.dcid);\n    value.setDCID(valueObj.dcid);\n    value.existsInKG = true;\n    return value;\n  }\n  return valueObj.value;\n}\n\n/**\n * Queries Data Commons to determine if a given dcid is a part of any\n * triples in the Knowledge graph.\n * @param {string} dcid The dcid to check if exists in Data Commons\n * @return {Promise<boolean>} Returns true if given dcid is in any triples in\n *     Data Commons Knowledge Graph.\n */\nasync function doesExistsInKG(dcid) {\n  const url = API_ROOT + '/node/triples?dcids=' + dcid + '&limit=1';\n  return fetch(url)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid] ? true : false);\n}\n\n/**\n * Indicates if a line should be parsed.\n * @param {string} line The line to be checked.\n * @return {boolean} False if the line is a comment or empty, otherwise\n *     true.\n */\nfunction shouldReadLine(line) {\n  if (line.startsWith('//') || line.length === 0 || line.startsWith('#')) {\n    return false;\n  }\n  return true;\n}\n\nexport {\n  ERROR_MESSAGES,\n  getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n  doesExistsInKG,\n  shouldReadLine,\n};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Module contains Node and Assertion classes which together create a local\n * version of the Data Commons Knowledge Graph.\n */\n\nimport {\n  doesExistsInKG,\n  getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n} from './utils.js';\n\n/** Class representation of a single Node in the KG. */\nclass Node {\n  /**\n   * The local id used in a parsed mcf file.\n   * @type {string}\n   */\n  localId;\n\n  /**\n   * Whether triples from the remote Data Commons Knowledge Graph have already\n   * been fetched.\n   * @type {boolean}\n   */\n\n  alreadyFetched;\n\n  /**\n   * Whether the node exists in the Data Commons Knowledge Graph.\n   * @type {boolean}\n   */\n  existsInKG;\n\n  /**\n   * Dcid of the node. Set only if a remote id is referred to in a local file or\n   * pulled from the Data Commons Knowledge Graph.\n   * @type {string}\n   */\n\n  dcid;\n  /**\n   * Array of Assertion objects representing the outgoing triples of the Node\n   * object.\n   * @type {Array<Assertion>}\n   */\n  assertions;\n  /**\n   * Array of Assertion objects representing the incoming triples of the Node\n   * object.\n   * @type {Array<Assertion>}\n   */\n  invAssertions;\n\n  /**\n   * Create a Node based on a given id.\n   * @param {string} id The id of the node to create, including the namespace.\n   */\n  constructor(id) {\n    this.localId = id.startsWith('l:') ? id : null;\n    this.dcid = null;\n\n    this.alreadyFetched = false;\n    this.existsInKG = false;\n\n    this.assertions = [];\n    this.invAssertions = [];\n\n    Node.nodeHash[id] = this;\n  }\n\n  /**\n   * Returns a node with the given ID, creates a new node if shouldCreate is\n   * true, or null if the node does not exist and a node should not be created.\n   *\n   * @param {string} id The id of the node to find, including the namespace.\n   * @return {Node|null} The found node if it exists or is created.\n   */\n  static getNode(id) {\n    const existing = Node.nodeHash[id];\n    return existing ? existing : new Node(id);\n  }\n\n  /**\n   * Indicates if a given object is an instance of Node class.\n   * @param {Object} obj The object to check.\n   * @return {boolean} True if the object is an instance of Node.\n   */\n  static isNode(obj) {\n    return obj instanceof Node;\n  }\n\n  /**\n   * Sets the dcid of Node object. Checks if a separate node based on the dcid\n   * already exists. If remote node exists, then the remote node is absorbed by\n   * current node via mergeNode() method.\n   *\n   * @param {string} dcid The dcid to be added to the Node object, should not\n   *     include the dcid namespace.\n   * @return {boolean} False if the node already has a different dcid, true\n   *     otherwise.\n   */\n  setDCID(dcid) {\n    if (this.dcid && this.dcid !== dcid) {\n      return false;\n    }\n\n    const remote = Node.nodeHash['dcid:' + dcid];\n    if (remote && remote !== this) {\n      this.mergeNode(remote);\n    }\n    this.dcid = dcid;\n    Node.nodeHash['dcid:' + dcid] = this;\n    return true;\n  }\n\n  /**\n   * Moves the assertions and inverse Assertions from the given param node to\n   * the calling Node object by changing the src property for assertions and the\n   * target property of the invAssertions.\n   *\n   * @param {Node} absorbedNode The node object whose triples should be copied.\n   */\n  mergeNode(absorbedNode) {\n    if (this.localId === absorbedNode.localId) {\n      return;\n    }\n\n    absorbedNode.assertions.forEach((assert) => {\n      assert.src = this;\n      this.assertions.push(assert);\n    });\n\n    absorbedNode.invAssertions.forEach((invAssert) => {\n      invAssert.target = this;\n      this.invAssertions.push(invAssert);\n    });\n  }\n\n  /**\n   * Sets the property existsInKG to true if the Node has triples in the DC KG.\n   */\n  async setExistsInKG() {\n    if (!this.dcid || this.existsInKG) {\n      return;\n    }\n    this.existsInKG = await doesExistsInKG(this.dcid);\n  }\n\n  /**\n   * Creates Assertion objects from a list of property labels by calling the\n   * helper function getRemotePropertyValues from utils.js to find the values\n   * in Data Commons given the current node, a property label, and the direction\n   * of the label.\n   *\n   * @param {Array<string>} propLabels List of property labels associated with\n   *     the calling Node object in Data Commons.\n   * @param {boolean} isInverse True if the list of labels are incoming labels,\n   *     meaning the calling Node object is the target of the triple. False if\n   *     the calling Node is the source of the triple.\n   */\n  async createAssertionsFromLabels(propLabels, isInverse) {\n    for (const label of propLabels) {\n      await getRemotePropertyValues(this.dcid, label, isInverse)\n          .then((valueList) => {\n            if (!valueList) {\n              throw new Error('No property values for dcid: ' + this.dcid +\n                              ' label: ' + label);\n            }\n\n            valueList.forEach((valueObj) => {\n              const val = getValueFromValueObj(valueObj);\n\n              if (isInverse && !Node.isNode(val)) {\n                throw new Error(\n                    'Error creating assertion with non Node source');\n              }\n\n              const source = isInverse ? val : this;\n              const target = isInverse ? this : val;\n\n              // if val is a node and has already been fetched, then the\n              // assertion would already be stored in both nodes\n              if (!Node.isNode(val) || !val.alreadyFetched) {\n                new Assertion(source, label, target, valueObj.provenanceId);\n              }\n            });\n          });\n    }\n  }\n\n  /**\n   * Stores remote triples as assertions and inverse Assertions of the calling\n   * Node object. Sets the alreadyFetched property to true if data is fetched.\n   */\n  async fetchRemoteData() {\n    if (this.alreadyFetched || !this.dcid) {\n      return;\n    }\n\n    await getRemotePropertyLabels(this.dcid).then(async (allLabels) => {\n      await this.createAssertionsFromLabels(allLabels.outLabels,\n          /* isInverse */ false);\n      await this.createAssertionsFromLabels(allLabels.inLabels,\n          /* isInverse */ true);\n    });\n    this.alreadyFetched = true;\n  }\n\n  /**\n   * Returns the reference to the node that is displayed in browser. If the\n   * node has a dcid, then the dcid will be displayed. If the node's local id\n   * is different, then the local id is also displayed.\n   * Ex: <dcid> [l:<localId>]\n   * @return {string} The reference to the node to be displayed.\n   */\n  getRef() {\n    const dcidRef = this.dcid ? this.dcid : '';\n    let localRef = '';\n\n    if (this.localId && !this.localId.includes('dcid')) {\n      localRef = '[' + this.localId + ']';\n    }\n    return [dcidRef, localRef].join(' ').trim();\n  }\n}\n\nNode.nodeHash = {}; // stores all created nodes\n\n/** Class representation of a single Assertion or triple in the KG. */\nclass Assertion {\n  /**\n   * The source or subject of the triple.\n   * @type {Node}\n   */\n  src;\n  /**\n   * The property label or predicate of the triple.\n   * @type {string}\n   */\n  property;\n  /**\n   * The provenance of the triple.\n   * @type {string}\n   */\n  provenance;\n  /**\n   * The target or object of the triple.\n   * @type {string|Node}\n   */\n  target;\n\n  /**\n   * Create a triple, setting the source's assertion prop to be the new object.\n   *\n   * @param {Node} src The source or subject of the triple.\n   * @param {string} property The property label of the triple.\n   * @param {Node|string} target The predicate or target of the triple.\n   * @param {string} provenance The provenance of the triple.\n   */\n  constructor(src, property, target, provenance) {\n    this.src = src;\n    this.property = property;\n    this.provenance = provenance;\n    this.target = target;\n\n    src.assertions.push(this);\n\n    if (target instanceof Object) {\n      target.invAssertions.push(this);\n    }\n  }\n}\n\nexport {Node, Assertion};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parses an mcf file and creates local knowledge graph of the parsed data\n * using Node and Assertion Class objects.\n */\n\nimport {Assertion, Node} from './graph.js';\nimport {ERROR_MESSAGES, shouldReadLine} from './utils.js';\n\nconst NAMESPACES = {\n  'l': 'l',\n  'schema': 'dcid',\n  'dcs': 'dcid',\n  'dcid': 'dcid',\n};\n\n/** Class responsible for parsing an mcf file. */\nclass ParseMcf {\n  /**\n   * Provenance to be used for any Assertion objects created during parsing,\n   * based off of the mcf file name.\n   * @type {string}\n   */\n  prov;\n  /**\n   * Current subject Node for any Assertion created. Set when a 'Node:' property\n   * label is parsed.\n   * @type {Node}\n   */\n  curNode;\n  /**\n   * Current line number of the line being parsed, used for identifying location\n   * of syntax error in the mcf file.\n   * @type {number}\n   */\n\n  lineNum;\n\n  /**\n   * List of error messages regarding mcf syntax that are to be displayed to\n   * the user. A single entry of this array should be in the format of:\n   * [line number, line, error message]\n   * @type {Array<Array<String>>}\n   */\n  errors;\n  /**\n   * Create a ParseMcf object which keeps tracks of the current source node of\n   * each triple in the mcf and the provenance, which is the mcf file name.\n   * @param {string} fileName Name of the file to be parsed.\n   */\n  constructor(fileName) {\n    this.prov = fileName;\n    this.curNode = null;\n    this.lineNum = -1;\n    this.errors = [];\n  }\n\n  /**\n   * Parses a string represetnaing a comma separated list of property values\n   * from a line of an mcf file. Returns a list having either a string or\n   * <namespace, reference> pair.\n   *\n   * @param {string} propValues A comma separated list of property values.\n   * @return {Array<(string|Object)>} Array of\n   *     parsed values.\n   */\n  parsePropValues(propValues) {\n    const values = [];\n    // split propValues on commas which are not enclosed by double quotes\n    for (const propValue of propValues.split(/,(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)) {\n      const namespace = propValue.split(':')[0].trim();\n      if (namespace in NAMESPACES) {\n        values.push({\n          'ns': namespace,\n          'ref': propValue.substring(propValue.indexOf(':') + 1).trim(),\n        });\n      } else if (propValue.split(':').length > 1 &&\n                 !namespace.startsWith('\"')) {\n        this.errors.push([this.lineNum, this.line, 'unrecognized namespace']);\n        return [];\n      } else {\n        // push property value with surrounding double quotes trimmed\n        values.push(propValue.replace(/^[\" ]*(.*?)[\" ]*$/g, '$1'));\n      }\n    }\n    return values;\n  }\n\n  /**\n   * Sets curNode variable of the calling ParseMcf object based on the passed in\n   * parsed values of a line of mcf, given the property label for the line was\n   * 'Node'. The parsed value either is a local reference with or without the\n   * 'l' namespace, or it has a remote namespace. If the namespace is remote,\n   * then the dcid for curNode is set. Updates localNodeHash mapping to store\n   * the subject nodes to be displayed in home screen of browser.\n   *\n   * @param {Array<string|Object>} parsedValues The array of parsed values from\n   *     a line of mcf with property label of 'Node'.\n   */\n  setCurNode(parsedValues) {\n    if (parsedValues.length !== 1) {\n      this.errors.push(\n          [this.lineNum, this.line, ERROR_MESSAGES['curNode-length']]);\n      return;\n    }\n\n    // handle case: Node: localRef, which means parsedValues[0]==='localRef'\n    let nodeRef = parsedValues[0];\n    let ns = '';\n\n    // handle case: Node: dcid:remoteRef, which means that\n    // parsedValues[0] === {'ns':'dcid', 'ref':'remoteRef' }\n    if (parsedValues[0] instanceof Object) {\n      ns = parsedValues[0]['ns'];\n      if (ns === 'dcid') {\n        ns = ns + ':';\n        nodeRef = parsedValues[0]['ref'];\n      } else {\n        this.errors.push(\n            [this.lineNum, this.line, ERROR_MESSAGES['curNode-ns']]);\n        return;\n      }\n    }\n    // combine the namespace and reference into single id\n    const nodeId = 'l:' + ns + nodeRef;\n    this.curNode = Node.getNode(nodeId);\n\n    if (ns === 'dcid:') {\n      this.curNode.setDCID(nodeRef);\n      ParseMcf.localNodeHash[ns + nodeRef] = this.curNode;\n    } else {\n      ParseMcf.localNodeHash[nodeId] = this.curNode;\n    }\n  }\n\n  /**\n   * Sets the dcid of the curNode variable of the calling ParseMcf object given\n   * the property label of the line being parsed is 'dcid'.\n   * @param {Array<string|Object>} parsedValues The array of parsed values from\n   *     a line of mcf with property label of 'dcid'.\n   */\n  setCurNodeDCID(parsedValues) {\n    if (!this.curNode) {\n      this.errors.push(\n          [this.lineNum, this.line, ERROR_MESSAGES['setDCID-noCur']]);\n      return;\n    }\n    if (parsedValues.length !== 1) {\n      this.errors.push(\n          [this.lineNum, this.line, ERROR_MESSAGES['setDCID-multiple']]);\n      return;\n    }\n    if (typeof parsedValues[0] !== 'string') {\n      this.errors.push(\n          [this.lineNum, this.line, ERROR_MESSAGES['setDCID-ref']]);\n      return;\n    }\n\n    if (!this.curNode.setDCID(parsedValues[0])) {\n      this.errors.push([this.lineNum, this.line, ERROR_MESSAGES['setDCID']]);\n    }\n  }\n\n  /**\n   * Create Assertion objects using curNode variable of calling ParseMcf object\n   * as the source of the triple and the prov variable of the ParseMcf object\n   * as the provenance of the triple.One Assertion object is created for each\n   * parsed value given in the array parsedValues.\n   *\n   * @param {string} propLabel The property label of the triple to be created.\n   * @param {Array<string|Object>} parsedValues The parsed values from a line of\n   *     mcf, used to create the target for each created triple.\n   */\n  createAssertionsFromParsedValues(propLabel, parsedValues) {\n    if (!this.curNode) {\n      this.errors.push(\n          [this.lineNum, this.line, ERROR_MESSAGES['assert-noCur']]);\n      return;\n    }\n    for (const val of parsedValues) {\n      let target = val;\n      if (val instanceof Object) {\n        target = Node.getNode(NAMESPACES[val['ns']] + ':' + val['ref']);\n        if (NAMESPACES[val['ns']] === 'dcid') {\n          if (!target.setDCID(val['ref'])) {\n            this.errors.push(\n                [this.lineNum, this.line, ERROR_MESSAGES['setDCID']]);\n          }\n        }\n      }\n      new Assertion(this.curNode, propLabel, target, this.prov);\n    }\n  }\n\n  /**\n   * Parses a single line of an mcf file. First determines if the line should be\n   * read, then finds the property label, then the property values and creates\n   * an Assertion object based on the triple, given the calling object has a\n   * curNode property that acts as the source  and a prov property that gives\n   * the provenance for the triple.\n   *\n   * @param {string} line The line of mcf to be parsed.\n   */\n  parseLine(line) {\n    line = line.trim();\n\n    if (!shouldReadLine(line)) {\n      return; // not an error\n    }\n\n    if (!line.includes(':')) {\n      this.errors.push(\n          [this.lineNum, this.line, ERROR_MESSAGES['parse-noColon']]);\n      return;\n    }\n\n    const propLabel = line.split(':', 1)[0].trim();\n    const propValues = line.substring(line.indexOf(':') + 1);\n\n    if (!propLabel) {\n      this.errors.push(\n          [this.lineNum, this.line, ERROR_MESSAGES['parse-noLabel']]);\n      return;\n    }\n    if (!propValues) {\n      this.errors.push(\n          [this.lineNum, this.line, ERROR_MESSAGES['parse-noValues']]);\n      return;\n    }\n\n    const parsedValues = this.parsePropValues(propValues);\n\n    switch (propLabel) {\n      case 'Node':\n        this.setCurNode(parsedValues);\n        break;\n\n      case 'dcid':\n        this.setCurNodeDCID(parsedValues);\n        break;\n\n      default:\n        this.createAssertionsFromParsedValues(propLabel, parsedValues);\n    }\n  }\n\n  /**\n   * Parses each line of the given string of an mcf file after setting the prov\n   * property of the calling ParseMcf object.\n   * @param {string} mcf The string representation of an mcf file to parse.\n   * @return {Object} A list of the local node ids and the list of error\n   * messages which should be empty if no mcf syntax errors were found.\n   */\n  parseMcfStr(mcf) {\n    const lines = mcf.split('\\n');\n    this.lineNum = 1;\n\n    lines.forEach((line) => {\n      this.line = line;\n      this.parseLine(line);\n      this.lineNum++;\n    });\n\n    return {\n      localNodes: Object.keys(ParseMcf.localNodeHash),\n      errMsgs: this.errors,\n    };\n  }\n\n  /**\n   * Reads an mcf file into a string, then creates ParseMcf object to parse the\n   * string.\n   * @param {FileObject} file An mcf file from the html file-input element.\n   * @return {Promise} Promise returns the result of parseMcfStr.\n   */\n  static readFile(file) {\n    const fileReader = new FileReader();\n    fileReader.readAsText(file);\n\n    return new Promise((res, rej) => {\n      fileReader.addEventListener('loadend', (result) => {\n        const mcfParser = new ParseMcf(file.name);\n        res(mcfParser.parseMcfStr(fileReader.result));\n      });\n      fileReader.addEventListener('error', rej);\n    });\n  }\n}\n\nParseMcf.localNodeHash = {}; // stores mapping of mcf subject IDs to the Node\n\nexport {ParseMcf};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as csv from 'csvtojson';\n\nimport {shouldReadLine} from './utils.js';\n\n/**\n * Returns the string following '->' in  a given string. Used for getting csv\n * column name when filling in tmcf with values from csv.\n * Ex:   C:SomeDataset->GeoId would return 'GeoId'\n * @param {string} propValue The string to look for a column name in.\n * @return {string|null} The column name that comes after '->'.\n */\nfunction getArrowId(propValue) {\n  if (propValue.includes('->')) {\n    return propValue.split('->')[1];\n  }\n  return null;\n}\n\n/**\n * Returns a string matching the format E:'DataSet Name'->'Entity #'.\n * @param {string} line The string to look for a match in.\n * @return {string|null} The entity id that matches the specified format.\n */\nfunction getEntityID(line) {\n  const localIdMatch = line.match('E:(.*)->(.*)');\n  if (localIdMatch) {\n    return localIdMatch[0];\n  }\n  return null;\n}\n\n/**\n * Generates a local id for a node of specfic row in csv from an entity id used\n * in tmcf file.\n * Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n * @param {string} entityID The entity id used in tmcf file.\n * @param {string} index The row number in the csv of the node to be created.\n * @return {string|null} The local id for the node of the specific csv row.\n */\nfunction getLocalIdFromEntityId(entityID, index) {\n  if (entityID) {\n    return entityID.replace('->', '_').replace('E:', '') + '_R' + index;\n  }\n  return null;\n}\n\n/**\n * Converts propertyValues from a line of tmcf to mcf by either converting\n * entity ids to local ids or replacing a csv column reference with the actual\n * value from the csv.\n *\n * @param {string} propValues The property values from the line of TMCF.\n * @param {Object} csvRow The JSON representation of a single row of a csv file.\n *     The keys are the column names and values are the corresponding entries of\n *     the csv for the specfic row/column.\n * @param {number} index The row number of the csvRow, used to generate a local\n *     id if needed.\n * @return {string} The mcf version of the given propValues which has local ids\n *     in lieu of entity ids and csv column references replaces with csv values.\n */\nfunction parsePropertyValues(propValues, csvRow, index) {\n  const parsedValues = [];\n\n  for (const propValue of propValues.split(',')) {\n    let parsedValue = propValue;\n\n    const entityID = getEntityID(propValue);\n\n    // convert entity id format to local id format\n    // Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n    if (entityID) {\n      const localId = 'l:' + getLocalIdFromEntityId(entityID, index);\n      parsedValue = parsedValue.replace(entityID, localId);\n    } else {\n      // Replace csv column placeholder with the value\n      const colName = getArrowId(propValue);\n      parsedValue = parsedValue.replace(/C:(.*)->(.*)/, csvRow[colName]);\n    }\n    parsedValues.push(parsedValue);\n  }\n  return parsedValues.join(',');\n}\n\n/**\n * Convert a row of csv to mcf using the tmcf as a template.\n * @param {string} template The string representation of tmcf file.\n * @param {Object} csvRow The JSON representation of a single row of a csv file.\n *     The keys are the column names and values are the corresponding entries of\n *     the csv for the specfic row/column.\n * @param {number} index The row number of the csvRow, used to generate a local\n *     id if needed.\n * @return {string} The constructed mcf for the single row from csv file.\n */\nfunction fillTemplateFromRow(template, csvRow, index) {\n  const filledTemplate = [];\n  for (const line of template.split('\\n')) {\n    if (!line.trim()) {\n      filledTemplate.push('');\n      continue;\n    }\n\n    if (!shouldReadLine(line)) {\n      continue;\n    }\n\n    const propLabel = line.split(':')[0].trim();\n\n    // TODO make this better\n    const propValues = line.replace(propLabel + ':', '').trim();\n\n    if (propLabel === 'Node') {\n      if (propValues.includes(',')) {\n        throw new Error('cannot have multiple ids for Node declaration');\n      }\n      let id = propValues;\n      const entityID = getEntityID(propValues);\n      if (entityID) {\n        id = getLocalIdFromEntityId(entityID, index);\n      }\n      filledTemplate.push(propLabel + ': ' + id);\n    } else {\n      const parsedValues = parsePropertyValues(propValues, csvRow, index);\n      filledTemplate.push(propLabel + ': ' + parsedValues);\n    }\n  }\n  return filledTemplate.join('\\n');\n}\n\n/**\n * Creates an mcf string from a string representation of TMCF file and the json\n * representation of a CSV file. The tmcf is populated with csv files for each\n * row of the csv.\n * @param {string} template The string representation of a tmcf file.\n * @param {Array<Object>} csvRows The json representation of the csv file. Each\n *     Object element of the array represents one row of the csv.\n * @return {string} The created mcf as a string.\n */\nfunction csvToMCF(template, csvRows) {\n  let index = 1;\n  const mcfStrList = [];\n  for (const row of csvRows) {\n    mcfStrList.push(fillTemplateFromRow(template, row, index));\n    index += 1;\n  }\n  return mcfStrList.join('\\n');\n}\n\n/**\n * Converts CSV file to an array of JS Object where each JS Object in the array\n * represents one row of the csv. The keys of the object are the column header\n * names and the values of the object are the csv entries in that column of the\n * given row the object represents.\n * @param {string} template The string representation of a tmcf file.\n * @param {FileObject} csvFile THe csv file from html file-input element.\n * @return {Array<Object>} The json representation of the csv file.\n */\nasync function readCSVFile(template, csvFile) {\n  const fileReader = new FileReader();\n  fileReader.readAsText(csvFile);\n  return new Promise((res, rej) => {\n    fileReader.addEventListener('loadend', (result) => {\n      csv().fromString(fileReader.result).then((csvRows) => {\n        console.log('csvFile: ' + csvFile.name);\n        const mcf = csvToMCF(template, csvRows);\n        res(mcf);\n      });\n    });\n    fileReader.addEventListener('error', rej);\n  });\n}\n\n/**\n * Reads a tmcf file and returns the contents as a string\n * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n * @return {string} The string representation of the tmcf file.\n */\nasync function readTMCFFile(tmcfFile) {\n  const fileReader = new FileReader();\n  fileReader.readAsText(tmcfFile);\n  return new Promise((res, rej) => {\n    fileReader.addEventListener('loadend',\n        (result) => {\n          res(fileReader.result);\n        });\n    fileReader.addEventListener('error', rej);\n  });\n}\n\n/**\n * Converts a TMCF file and CSV file to an MCF string.\n * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n * @param {FileObject} csvFile THe csv file from html file-input element.\n * @return {string} The translated mcf as a string.\n */\nasync function tmcfCSVToMCF(tmcfFile, csvFile) {\n  return readTMCFFile(tmcfFile).then((template) =>\n    readCSVFile(template, csvFile));\n}\n\nexport {\n  tmcfCSVToMCF,\n  csvToMCF,\n  fillTemplateFromRow,\n  getLocalIdFromEntityId,\n  getEntityID,\n  getArrowId,\n  parsePropertyValues,\n};\n","import {Node} from './graph.js';\nimport {ParseMcf} from './parse-mcf.js';\nimport * as ParseTMCF from './parse-tmcf.js';\n\n/**\n * Parses App state's fileList to find either one mcf file or one set of\n * tmcf+csv. Parses the files according to their file type.\n * @param {Array<FileBlob>} fileList The list of files to load into memory.\n * @return {Array<string>} An array of local ids from Node.nodeLocalHash.\n */\nasync function readFileList(fileList) {\n  let tmcfFile;\n  let csvFile;\n  let mcfFile;\n  for (const file of fileList) {\n    if (file.name.endsWith('.tmcf')) {\n      tmcfFile = file;\n    } else if (file.name.endsWith('.csv')) {\n      csvFile = file;\n    } else {\n      mcfFile = file;\n    }\n  }\n\n  if (mcfFile) {\n    return ParseMcf.readFile(mcfFile);\n  }\n\n  if (tmcfFile && csvFile) {\n    return ParseTMCF.tmcfCSVToMCF(tmcfFile, csvFile).then((mcf) => {\n      console.log(mcf);\n      const mcfParser = new ParseMcf(tmcfFile.name + '&' + csvFile.name);\n      return mcfParser.parseMcfStr(mcf);\n    });\n  }\n  return {'errMsgs': [], 'localNodes': []};\n}\n\nfunction clearFiles() {\n  Node.nodeHash = {};\n  ParseMcf.localNodeHash = {};\n}\n\nfunction retrieveNode(id, shouldCreateRemote) {\n  const foundNode = Node.getNode(id);\n  if (shouldCreateRemote) {\n    foundNode.setDCID(id.replace('dcid:', ''));\n  }\n  // should make dcid from search bar\n  console.log(ParseMcf.localNodeHash[id]);\n  console.log('retrieve');\n  console.log(foundNode);\n  return foundNode;\n}\n\nfunction isNodeObj(obj) {\n  return Node.isNode(obj);\n}\n\nasync function getElemId(target) {\n  if (!target) {\n    return null;\n  }\n  if (target.existsInKG) {\n    return 'blue';\n  }\n\n  return target.setExistsInKG().then(() => {\n    if (target.existsInKG) {\n      return 'blue';\n    }\n\n    if (!target.dcid && target.localId &&\n        target.localId in ParseMcf.localNodeHash) {\n      return 'purple';\n    }\n\n    if (!target.dcid && !(target.localId in ParseMcf.localNodeHash)) {\n      return 'orange';\n    }\n    return 'red';\n  });\n}\n\nfunction localNodeHashExists() {\n  return (ParseMcf.localNodeHash) ? true : false;\n}\nexport {\n  readFileList,\n  clearFiles,\n  retrieveNode,\n  isNodeObj,\n  getElemId,\n  localNodeHashExists,\n};\n","let fileHash = '#';\n/**\n * Sets the window hash value to query a given id.\n * @param {string} id The id of the desired node to display. This can be either\n *     a dcid or a local id.\n */\nfunction goToId(id) {\n  if (id.includes(':')) {\n    window.location.hash = fileHash + '&id=' + id;\n  } else {\n    window.location.hash = fileHash + '&id=dcid:' + id;\n  }\n}\n\nfunction searchId(id) {\n  if (id.includes(':')) {\n    window.location.hash = fileHash + '&search=' + id;\n  } else {\n    window.location.hash = fileHash + '&search=dcid:' + id;\n  }\n}\n\n/**\n * Sets the window hash value to empty to redirect user to home page.\n */\nfunction goToHome() {\n  console.log(fileHash)\n  window.location.hash = fileHash;\n}\n\nfunction setFileHash(fileUrlList) {\n  fileHash = '#'\n  for (const fileUrl of fileUrlList) {\n    fileHash += '&file=' + fileUrl;\n  }\n}\n\nfunction openFile(fileUrl) { window.open(fileUrl); }\n\nexport {goToId, goToHome, setFileHash, openFile, searchId};\n","import './App.css';\n\nimport React, {Component} from 'react';\n\nimport * as API from './back-end/server-api.js';\nimport * as utils from './utils.js';\n\nconst NON_BREAKING_SPACE = '\\u00a0';\n\n/**\n * Returns an html element of the missing cell value in a triple. If the current\n * triple is an outgoing assertion (current node displayed is the source of the\n * triple) then this method will be called on the target. If the current triple\n * is an inverse assertions, then this method is called on the source of the\n * triple.\n * Determines if the target is another node and should be\n * clickable, what color it should be, and the node reference that should be\n * displayed (dcid vs dcid [l:localId] vs [l:localId]). If the target is not\n * another node, then an html element of pure text is returned.\n * @param {Node|string} target The source of an inverse assertion or the target\n *     of a direct assertion.\n * @return {HtmlElement} A single cell of an html row representing a triple.\n *     Either the source or target of the triple depending if the triple is\n *     inverse or not.\n */\nasync function getMissingVal(target) {\n  if (API.isNodeObj(target)) {\n    const elemId = await API.getElemId(target);\n    return (<td><p id = {elemId} className = 'clickable' onClick =\n                     {() => utils.goToId(target.localId || target.dcid)}>{\n        target.getRef()}</p></td>);\n  }\n  return (<td >{target}</td>);\n}\nfunction onProvClick(elemId, prov){\n  if(elemId){\n    utils.goToId(prov)\n  } else{\n    utils.openFile(prov)\n  }\n}\n/**\n * Returns an html element row representing the given assertion.\n * @param {Assertion} assert The assertion/triple to create the html row from.\n * @param {boolean} isInverse True if the assertion is inverse, meaning the\n *     currently displayed node is the target of the triple.\n * @param {number} index Used to create a unique key for the html row element.\n * @return {HtmlElement} A row represeting the given triple.\n */\nasync function getRowFromTriple(assert, isInverse, index ) {\n  const missingVal = isInverse ? assert.src : assert.target;\n  const val = await getMissingVal(missingVal);\n\n  let rowClassName;\n  let provId = 'black';\n  let provName = assert.provenance;\n  let provElem = (<p id={provId} className='clickable'\n     onClick={() => onProvClick(provId, assert.provenance)}>{provName}</p>)\n  if(provName.startsWith('https')){\n    rowClassName = 'bold';\n    provId = '';\n    const provNames = [];\n    for (const fileName of provName.split('&')) {\n      provNames.push(fileName.split('/').pop());\n    }\n    provElem = (<p id={provId} className='clickable'\n       onClick={() => onProvClick(provId, assert.provenance)}>{provNames[0]}</p>)\n\n    if(provNames.length > 1){\n      provElem = (<div>\n        <p id={provId} className='clickable'\n           onClick={() => onProvClick(provId, assert.provenance.split('&')[0])}>{provNames[0]}</p>\n         <p>,{NON_BREAKING_SPACE}</p>\n           <p id={provId} className='clickable'\n              onClick={() => onProvClick(provId, assert.provenance.split('&')[1])}>{provNames[1]}</p>\n      </div>)\n    }\n  }\n  return (\n    <tr className={rowClassName} key={assert.property + index}>\n      <td>{assert.property}</td>\n      {val}\n      <td>{provElem}</td>\n    </tr>\n  );\n  }\n\n  /**\n   * Converts a list of Assertion objects to an array of HTML row elements that\n   * is displyed in the TriplesTable.\n   * @param {Array<Assertion>} asserts An array of Assertion objects to display\n   *     in the TriplesTable component.\n   * @param {boolean} isInverse True if the current node displayed is the target\n   *     for each of the assertions.\n   * @return {Array<HtmlElement>} The array of HTML row elements representing\n   *     each triple.\n   */\n  async function getTripleRows(asserts, isInverse) {\n    const tripleRows = [];\n    let index = 0; // used to create a unique key for each row element\n    for (const assert of asserts) {\n      const tripleRow = await getRowFromTriple(assert, isInverse, index);\n      tripleRows.push(tripleRow);\n      index += 1;\n    }\n    return tripleRows;\n  }\n\n  function getTableHeaders(isInverse) {\n    if (isInverse) {\n      return (<tr><th>Property</th>\n        <th>Source</th>\n              <th>Provenance</th>\n      </tr>);\n    }\n    return (<tr><th>Property</th>\n      <th>Target</th>\n            <th>Provenance</th>\n    </tr>);\n  }\n\n  /** Displays all given triples as a table */\n  export class TriplesTable extends Component {\n    /** Creates TriplesTable component. */\n    constructor(props) {\n      super(props);\n\n      this.state = {\n        tableRows : null,\n        loading : true,\n      };\n    }\n\n    /**\n     * Gets rows of triples when the array of Assertions from props is updated.\n     * @param {Object} prevProps The previous props before the component\n     *     updated, used to compare if the passed in triples have been modified.\n     */\n    componentDidUpdate(prevProps) {\n      if (prevProps.triples !== this.props.triples) {\n        this.setState({loading : true});\n        getTripleRows(this.props.triples, this.props.inverse).then((rows) => {\n          this.setState({tableRows : rows, loading : false});\n        });\n      }\n    }\n\n    /** Renders TriplesTable component.   */\n    render() {\n      if (this.state.loading)\n        return null;\n\n      const tableHeaders = getTableHeaders(this.props.inverse);\n\n    return (\n      <table>\n        <thead>\n          {tableHeaders}\n        </thead>\n        <tbody>{this.state.tableRows}</tbody>\n      </table>\n    );\n  }\n}\n","import './App.css';\n\nimport React, {Component} from 'react';\n\nimport * as API from './back-end/server-api.js';\nimport {TriplesTable} from './TriplesTable.js';\n\nconst COLOR_LEGEND =\n    (<div><p className = 'inline'>|\n     </p>\n    <p className='inline' id='blue'>Node has dcid that exists in DC KG</p>\n     <p className = 'inline'>|\n     </p>\n    <p className='inline' id='purple'>Node has resolved local reference and no dcid</p>\n     <p className = 'inline'>|\n     </p>\n    <p className='inline' id='orange'>Node has unresolved local reference and no dcid</p>\n     <p className = 'inline'>|\n     </p>\n    <p className='inline' id='red'>Default; Node has dcid which does not exist in DC KG</p>\n     <p className = 'inline'>|\n     </p>\n  </div>)\n\n/** Displays node data for a given node passed in through props. */\nclass DisplayNode extends Component {\n  /** Creates DisplayNode component. */\n  constructor(props) {\n    super(props);\n    this.state = {\n      ref : null,\n      asserts : [],\n      invAsserts : [],\n      fetching : true,\n    };\n    console.log('display constructor')\n  }\n\n  /** Sets node data when the component mounts. */\n  componentDidMount() { this.setNodeData(); }\n\n  /**\n   * Sets node data when the node to display changes.\n   * @param {Object} prevProps The previous props before the component updated,\n   *     used to compare if the passed in node has changed.\n   */\n  componentDidUpdate(prevProps) {\n    if (prevProps.node !== this.props.node) {\n      this.setNodeData();\n    }\n  }\n\n  /**\n   * Loads data to display for the node passed in through props. This includes\n   * fetching the remote data from DC KG for the node.\n   */\n  setNodeData() {\n    console.log(this.props.node);\n\n    const curNode = this.props.node;\n    this.setState({\n      ref : curNode.getRef(),\n      fetching : true,\n      asserts : [],\n      invAsserts : []\n    });\n\n    API.getElemId(curNode).then((elemId) => this.setState({elemId : elemId}));\n\n    curNode.fetchRemoteData().then(() => {\n      this.setState({\n        asserts : curNode.assertions,\n        invAsserts : curNode.invAssertions,\n        fetching : false\n      });\n    });\n  }\n\n  /** Renders the DisplayNode component. */\n  render() {\n    let fetching;\n    if (this.state.fetching) {\n      fetching = (<div className = 'div-col'><br>\n                  </br>\n            <div className='loadingSpinner'></div>\n                  <h2>...fetching triples...</h2>\n        </div>);\n    }\n    return (\n      <div>\n        {COLOR_LEGEND}\n        <br></br>\n        <h1 className='inline'>Currently Viewing: </h1>\n        <h1 className='inline' id={this.state.elemId}>{this.state.ref}</h1>\n      <br></br>\n      {fetching}\n      <div className='node'>\n        <h3 id='indent' className='inline'>Node Properties</h3>\n        <p className='inline'> - current node is source</p>\n          <br></br>\n        <TriplesTable triples={this.state.asserts} inverse={false}/>\n        <br></br>\n        <h3 id='indent' className='inline'>Incoming Properties from Other Nodes</h3>\n        <p className='inline'> - current node is target</p>\n          <br></br>\n\n        <TriplesTable triples={this.state.invAsserts} inverse={\n      true}/>\n      </div>\n\n    </div>\n    );\n  }\n}\nexport {DisplayNode};\n","import './App.css';\n\nimport React, {Component} from 'react';\n\nimport * as utils from './utils.js';\n\n/** Header component contains the id search bar and return home button. */\nclass Header extends Component {\n  /**\n   * Calls utils method goToId to search for an id when the user presses enter.\n   * @param {Event} event OnKeyUp  event from html search input element.\n   */\n  handleSearch(event) {\n    if (event.keyCode === 13) {\n      utils.searchId(event.target.value);\n    }\n  }\n  /** Renders header element. */\n  render() {\n    return (\n      <div className='header'>\n        <button onClick = {() => utils.goToHome() }>Return Home</button>\n        <input type=\"search\" onKeyUp={this.handleSearch}\n          placeholder=\"Search id, use 'dcid:' namespace for remote lookup...\" />\n      </div>\n    );\n  }\n}\nexport {Header};\n","import './App.css';\n\nimport React, {Component} from 'react';\n\nimport * as API from './back-end/server-api.js';\nimport {DisplayNode} from './DisplayNode.js';\nimport {Header} from './Header.js';\nimport * as utils from './utils.js';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      subjNodes : [],\n      curNode : null,\n      fileList : [],\n      loading : null,\n      fileHash : '',\n      firstLoad : true,\n      searchErrMsg : '',\n      parsingErrs : [],\n    };\n  }\n  /** Adds an event listener to the window to respond to url hash changes. */\n  componentDidMount() {\n    window.addEventListener('hashchange', () => this.handleHashChange(), false);\n    if (this.state.firstLoad) {\n      console.log('first app load');\n      this.loadUrlFiles();\n      this.setState({firstLoad : false});\n    }\n  }\n\n  loadUrlFiles() {\n    const params = new URLSearchParams(window.location.hash.split('#')[1]);\n\n    // get path to file(s) from urls\n    const fileUrls = params.getAll('file');\n\n    if (fileUrls.length) {\n\n      this.loadRemoteFiles(0, fileUrls);\n\n      utils.setFileHash(fileUrls);\n    } else {\n      // get node to display from url\n      let node;\n      const searchId = params.get('id');\n      console.log(searchId)\n      if (searchId) {\n        node = API.retrieveNode(searchId, /* shouldCreateRemote */ true);\n        this.setState({curNode : node});\n        console.log(node)\n      }\n    }\n  }\n\n  /**\n   * Sets App state according to url parameters 'id' and 'file'. The param 'id'\n   * will cause the display node page to appear with the node of the specified\n   * id. The 'file' param followed by url to a file will cause that file to be\n   * loaded and parsed if it is one url to mcf or two 'file' params with one a\n   * url to a tmcf and the other a url to a csv file.\n   */\n  handleHashChange() {\n    const params = new URLSearchParams(window.location.hash.split('#')[1]);\n    // get node to display from url\n\n    let nodeId = params.get('id');\n\n    let node = null;\n    if (nodeId) {\n      node = API.retrieveNode(nodeId, false);\n    }\n\n    if (!nodeId) {\n      let searchId = params.get('search');\n\n      node = null;\n      if (searchId) {\n        node = API.retrieveNode(searchId, true);\n      }\n    }\n    this.setState({curNode : node});\n\n    const err = params.get('search');\n    console.log(err)\n    let errMsg = '';\n    if (err === 'noLocalFiles') {\n      console.log('errMsg')\n      errMsg = 'Use dcid namespace if searching for remote node or ' +\n               'load a file to search for a local id.'\n    } else if (err) {\n      errMsg = 'Error occured in search. Verify node you are trying to find.'\n    }\n    this.setState({searchErrMsg : errMsg});\n  }\n\n  /**\n   * Gets a remote file from an Array of urls at index i and appends the\n   * retrieved file to App state's fileList. This is a recursive method that\n   * calls itself to iterate through the entire Array of fileUrls.\n   * @param {number} i The index of the url to get from fileUrls array.\n   * @param {Array<string>} fileUrls The array of file urls to load and append\n   *     to App state's fileList.\n   */\n  loadRemoteFiles(i, fileUrls) {\n    if (i >= fileUrls.length) {\n      this.submitFileList();\n      return;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'blob';\n    xhr.open('GET', fileUrls[i]);\n    console.log('loading: ' + fileUrls[i]);\n    xhr.onload = () => {\n      console.log('finished loading');\n      console.log(xhr.response);\n      xhr.response.name = fileUrls[i];\n      console.log(xhr.response.name);\n       this.setState(\n          {fileList : this.state.fileList.concat(xhr.response)});\n      this.loadRemoteFiles(i + 1, fileUrls);\n    };\n    xhr.send();\n  }\n\n  /**\n   * Passes App state's fileList array to the 'back-end' API to be parsed and\n   * the files loaded into memory.\n   */\n  submitFileList() {\n    this.setState({\n      loading: (\n          <div><div className = 'loadingSpinner'>\n          </div>\n        <h2>...loading mcf...</h2>\n          </div>)});\n\n    API.readFileList(this.state.fileList)\n        .then( (res) => {\n          console.log(res);\n          this.setState({parsingErrs: res['errMsgs'], subjNodes: res['localNodes'], loading: null})\n          this.handleHashChange();\n        });\n  }\n\n  /**\n   * Clear App state and calls the 'back-end' API clearFiles method.\n   */\n  onClearPress() {\n    this.setState({subjNodes: [], fileList: [], loading: null});\n    API.clearFiles();\nwindow.location.hash = '#'\n  }\n  /**\n    * Renders the browser by displaying a specific node or the homepage.\n    */\n  render() {\n\n    let display;\n    if (this.state.curNode) {\n      display =  (\n      \t<DisplayNode node={this.state.curNode} />);\n    } else{\n      display = (\n        <div className='Home'>\n        <h3>{this.state.searchErrMsg}</h3>\n        <div className='div-row'>\n\n          <div id='curFiles'>\n          <h3>Current Files:</h3>\n          <ul >{this.state.fileList.map( (file) =>\n            <li className='clickable' onClick={()=>utils.openFile(file.name)} key={file.name}>{file.name}</li>,\n          )}</ul>\n          <br></br>\n          <button onClick={() => this.onClearPress()} >Clear</button>\n          <br></br>\n          {this.state.parsingErrs.length ?\n            (\n              <div>\n              <h3>Parsing Errors:</h3>\n              <table >\n                <thead>\n                <tr>\n                  <th id='errorTable'>Line Num</th>\n                  <th id='errorTable'>Line</th>\n                  <th id='errorTable'>Error Message</th>\n                </tr></thead>\n                <tbody>{this.state.parsingErrs.map( (msg) =>\n                  <tr key={msg[0]}>\n                    <td>{msg[0]}</td>\n                      <td>{msg[1]}</td>\n                        <td>{msg[2]}</td>\n                  </tr>\n                )}\n                </tbody>\n              </table>\n                    </div>\n                  ):\n          (\n            <div>\n            <h3>Subject Nodes:</h3>\n          <ul>{this.state.subjNodes.map( (dcid) =>\n            <li className='clickable' key={dcid} onClick={() => utils.goToId(dcid)}>{dcid}</li>,\n          )}</ul>\n          </div>\n      )}\n          {this.state.loading}\n      </div>\n\n          <div id='uploadFiles'>\n            <h3>Upload one MCF file or one set of TMCF+CSV files to preview in Data Commons.</h3>\n            <div>\n          <input id=\"file-select\" onChange={\n      (event) => {\n        this.setState({\n          fileList : this.state.fileList.concat(Array.from(event.target.files))\n        })\n      } }\n            type=\"file\" name=\"UploadFile\" accept=\".mcf,.tmcf,.csv\" required multiple />\n            <button onClick={() => this.submitFileList()} >Submit</button>\n            </div>\n          </div>\n              </div>\n        </div>\n      )\n    }\n\n    return (\n      <div className=\"App\">\n        <Header />\n        {display}\n      </div>\n\n    );\n  }\n}\nexport default App;\n","import './index.css';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n"],"sourceRoot":""}