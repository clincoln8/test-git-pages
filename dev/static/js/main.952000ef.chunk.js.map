{"version":3,"sources":["back-end/utils.js","back-end/graph.js","back-end/parse-mcf.js","back-end/parse-tmcf.js","back-end/server-api.js","utils.js","Header.js","TriplesTable.js","DisplayNode.js","App.js","index.js"],"names":["API_ROOT","getRemotePropertyLabels","dcid","a","targetUrl","fetch","then","res","json","data","JSON","parse","payload","getRemotePropertyValues","label","isInverse","triples","in","out","getValueFromValueObj","valueObj","Error","value","Node","getNode","setDCID","existsInKG","doesExistsInKG","url","shouldReadLine","line","startsWith","length","id","this","localId","alreadyFetched","assertions","invAssertions","dcidRef","localRef","join","trim","remote","nodeHash","mergeNode","absorbedNode","getAssertions","forEach","assert","src","nextAssertion","getInvAssertions","invAssert","target","invNextAssertion","propLabels","valueList","val","isNode","Assertion","provenanceId","allLabels","createAssertionsFromLabels","outLabels","inLabels","assertList","push","invAssertList","obj","existing","newNode","property","provenance","Object","NAMESPACES","ParseMcf","fileFullName","fileName","includes","fileNameSpiltOnPeriod","split","pop","prov","curNode","lineNum","propValues","values","propValue","namespace","substring","indexOf","parsedValues","toString","nodeId","ns","localNodeHash","replace","propLabel","parsePropValues","setCurNode","setCurNodeDCID","createAssertionsFromParsedValues","mcf","lines","parseLine","file","fileReader","FileReader","readAsText","Promise","rej","addEventListener","result","mcfParser","name","parseMcfStr","getArrowId","getEntityID","localIdMatch","match","getLocalIdFromEntityId","entityID","index","parsePropertyValues","csvRow","parsedValue","colName","fillTemplateFromRow","template","filledTemplate","csvToMCF","csvRows","mcfStrList","row","readCSVFile","csvFile","csv","fromString","console","log","readTMCFFile","tmcfFile","tmcfCSVToMCF","fileList","endsWith","mcfFile","readFile","localHash","keys","ParseTMCF","retrieveNode","shouldCreateRemote","foundNode","isNodeObj","getClassName","setExistsInKG","fileHash","goToId","window","location","hash","Header","event","keyCode","utils","className","onClick","type","onKeyUp","handleSearch","placeholder","Component","getMissingVal","API","getRef","getRowFromTriple","missingVal","key","asserts","tripleRows","tripleRow","TriplesTable","props","state","tableRows","loading","prevProps","setState","getTripleRows","inverse","rows","tableHeaders","DisplayNode","ref","invAsserts","fetching","setNodeData","node","fetchRemoteData","table","App","subjNodes","firstLoad","searchErrMsg","handleHashChange","loadUrlFiles","params","URLSearchParams","fileUrls","getAll","getRemoteFile","fileUrlList","fileUrl","searchDCId","get","searchId","err","errMsg","i","submitFileList","xhr","XMLHttpRequest","responseType","open","onload","response","URL","pathname","concat","send","subjList","display","map","onClearPress","onChange","Array","from","files","accept","required","multiple","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.952000ef.chunk.js","sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Module contains helper functions for api calls to data commons as well as\n * helper functions for parsing file to create local knowledge graph.\n */\n\nimport {Node} from './graph.js';\nconst API_ROOT = 'https://api.datacommons.org';\n\n/**\n * Gets all property labels of the given dcid that are in the DC KG.\n *\n * @param {string} dcid The dcid of the node to find property labels for.\n * @return {Object} An object containing both 'in' and 'out' property labels.\n */\nasync function getRemotePropertyLabels(dcid) {\n  const targetUrl = API_ROOT + '/node/property-labels?dcids=' + dcid;\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid]);\n}\n\n/**\n * Gets all property values containing the given dcid, property label, and\n * direction.\n *\n * @param {string} dcid The dcid of the node to find property value for.\n * @param {string} label The property label to query for.\n * @param {boolean} isInverse Direction of property label, false indicates\n *     an outgoing label, true is an incoming label.\n * @return {Object} An object containing all found values matching the query.\n */\nasync function getRemotePropertyValues(dcid, label, isInverse) {\n  const direction = isInverse ? 'in' : 'out';\n  const targetUrl =\n      (API_ROOT + '/node/property-values?limit=500&dcids=' + dcid +\n       '&property=' + label + '&direction=' + direction);\n\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid])\n      .then((triples) => isInverse ? triples.in : triples.out);\n}\n\n/**\n * Parses an Object returned from the DC REST get_values API to create a Node\n * object from the value's dcid or to return the string value that the object\n * holds.\n *\n * @param {Object} valueObj An object returned from DC REST get_values API.\n * @return {Node | string} The created Node if the value object has a dcid,\n *     otherwise the string of the value.\n */\nfunction getValueFromValueObj(valueObj) {\n  if (!('dcid' in valueObj || 'value' in valueObj)) {\n    throw new Error('ERROR remote fetch no dcid or value prop: ' + valueObj);\n  }\n\n  if ('dcid' in valueObj) {\n    const value = Node.getNode(valueObj.dcid);\n    value.setDCID(valueObj.dcid);\n    value.existsInKG = true;\n    return value;\n  }\n  return valueObj.value;\n}\n\n/**\n * Queries Data Commons to determine if a given dcid is a part of any\n * triples in the Knowledge graph.\n * @param {string} dcid The dcid to check if exists in Data Commons\n * @return {Promise<boolean>} Returns true if given dcid is in any triples in\n *     Data Commons Knowledge Graph.\n */\nasync function doesExistsInKG(dcid) {\n  const url = API_ROOT + '/node/triples?dcids=' + dcid + '&limit=1';\n  return fetch(url)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid] ? true : false);\n}\n\n/**\n * Indicates if a line should be parsed.\n * @param {string} line The line to be checked.\n * @return {boolean} False if the line is a comment or empty, otherwise\n *     true.\n */\nfunction shouldReadLine(line) {\n  if (line.startsWith('//') || line.length === 0 || line.startsWith('#')) {\n    return false;\n  }\n  return true;\n}\n\nexport {\n  getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n  doesExistsInKG,\n  shouldReadLine,\n};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Module contains Node and Assertion classes which together create a local\n * version of the Data Commons Knowledge Graph.\n */\n\nimport {\n  doesExistsInKG,\n  getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n} from './utils.js';\n\n/** Class representation of a single Node in the KG. */\nclass Node {\n  /**\n   * Universal id of the node. Every Node obj has a localId, which is either a\n   * local reference used in an uplaoded file, or the dcid if the node is never\n   * referred to locally (remote only Node).\n   * @type {string}\n   */\n  localId;\n  /**\n   * Whether triples from the remote Data Commons Knowledge Graph have already\n   * been fetched.\n   * @type {boolean}\n   */\n  alreadyFetched;\n  /**\n   * Whether the node exists in the Data Commons Knowledge Graph.\n   * @type {boolean}\n   */\n  existsInKG;\n  /**\n   * Dcid of the node. Set only if a remote id is referred to in a local file or\n   * pulled from the Data Commons Knowledge Graph.\n   * @type {?string}\n   */\n  dcid;\n  /**\n   * The head of a linked list of Assertion objects representing the outgoing\n   * triples of the Node object.\n   * @type {?Assertion}\n   */\n  assertions;\n  /**\n   * The head of a linked list of Assertion objects representing the incoming\n   * triples of the Node object.\n   * @type {?Assertion}\n   */\n  invAssertions;\n\n  /**\n   * Create a Node based on a given id.\n   * @param {string} id The id of the node to create.\n   */\n  constructor(id) {\n    this.localId = id;\n    this.alreadyFetched = false;\n    this.existsInKG = false;\n    this.dcid = null;\n    this.assertions = null;\n    this.invAssertions = null;\n  }\n\n  /**\n   * Indicates if a given object is an instance of Node class.\n   * @param {Object} obj The object to check.\n   * @return {boolean} True if the object is an instance of Node.\n   */\n  static isNode(obj) { return obj instanceof Node; }\n\n  /**\n   * Returns a node with the given ID, creates a new node if shouldCreate is\n   * true, or null if the node does not exist and a node should not be created.\n   *\n   * @param {string} id The id of the node to find.\n   * @param {boolean} shouldCreate True if a new Node should be created if it\n   *     does not already exist.\n   * @return {Node|null} The found node if it exists or is created.\n   */\n  static getNode(id) {\n    const existing = Node.nodeHash[id];\n    if (existing) {\n      return existing;\n    }\n\n    const newNode = new Node(id);\n    Node.nodeHash[id] = newNode;\n    return newNode;\n\n  }\n\n  /**\n   * Returns the reference to the node that is displayed in browser. If the\n   * node has a dcid, then the dcid will be displayed. If the node's local id\n   * is different, then the local id is also displayed.\n   * Ex: <dcid> [l:<localId>]\n   * @return {string} The reference to the node to be displayed.\n   */\n  getRef() {\n    const dcidRef = this.dcid ? this.dcid : '';\n    let localRef = '';\n\n    if (!this.dcid || this.dcid !== this.localId) {\n      localRef = '[l:' + this.localId + ']';\n    }\n    return [ dcidRef, localRef ].join(' ').trim();\n  }\n\n  /**\n   * Sets the dcid of Node object. Checks if a separate node based on the dcid\n   * already exists. If remote node exists, then the remote node is absorbed by\n   * current node via mergeNode() method.\n   *\n   * @param {string} dcid The dcid to be added to the Node object.\n   */\n  setDCID(dcid) {\n    const remote = Node.nodeHash[dcid];\n    if (remote) {\n      this.mergeNode(remote);\n    }\n    this.dcid = dcid;\n    Node.nodeHash[dcid] = this;\n  }\n\n  /**\n   * Moves the assertions and inverse Assertions from the given param node to\n   * the calling Node object by changing the src property for assertions and the\n   * target property of the invAssertions.\n   *\n   * @param {Node} absorbedNode The node object whose triples should be copied.\n   */\n  mergeNode(absorbedNode) {\n    if (this.localId === absorbedNode.localId) {\n      return;\n    }\n\n    absorbedNode.getAssertions().forEach((assert) => {\n      assert.src = this;\n      assert.nextAssertion = this.assertions;\n      this.assertions = assert;\n    });\n\n    absorbedNode.getInvAssertions().forEach((invAssert) => {\n      invAssert.target = this;\n      invAssert.invNextAssertion = this.invAssertions;\n      this.invAssertions = invAssert;\n    });\n  }\n\n  /**\n   * Sets the property existsInKG to true if the Node has triples in the DC KG.\n   */\n  async setExistsInKG() {\n    if (!this.dcid || this.existsInKG) {\n      return;\n    }\n    this.existsInKG = await doesExistsInKG(this.dcid);\n  }\n\n  /**\n   * Creates Assertion objects from a list of property labels by calling the\n   * helper function getRemotePropertyValues from utils.js to find the values\n   * in Data Commons given the current node, a property label, and the direction\n   * of the label.\n   *\n   * @param {Array<string>} propLabels List of property labels associated with\n   *     the calling Node object in Data Commons.\n   * @param {boolean} isInverse True if the list of labels are incoming labels,\n   *     meaning the calling Node object is the target of the triple. False if\n   *     the calling Node is the source of the triple.\n   */\n  async createAssertionsFromLabels(propLabels, isInverse) {\n    for (const label of propLabels) {\n      await getRemotePropertyValues(this.dcid, label, isInverse)\n          .then((valueList) => {\n            if (!valueList) {\n              throw new Error('No property values for dcid: ' + this.dcid +\n                              ' label: ' + label);\n            }\n\n            valueList.forEach((valueObj) => {\n              const val = getValueFromValueObj(valueObj);\n\n              if(isInverse && !Node.isNode(val)){\n                  throw new Error('Error creating assertion with non Node source');\n                }\n                \n              const source = isInverse ? val : this;\n              const target = isInverse ? this : val;\n              new Assertion(source, label, target, valueObj.provenanceId);\n            });\n          });\n    }\n  }\n\n  /**\n   * Stores remote triples as assertions and inverse Assertions of the calling\n   * Node object. Sets the alreadyFetched property to true if data is fetched.\n   */\n  async fetchRemoteData() {\n    if (this.alreadyFetched || !this.dcid) {\n      return;\n    }\n\n    await getRemotePropertyLabels(this.dcid).then(async (allLabels) => {\n      await this.createAssertionsFromLabels(allLabels.outLabels,\n                                            /* isInverse */ false);\n      await this.createAssertionsFromLabels(allLabels.inLabels,\n                                            /* isInverse */ true);\n    });\n    this.alreadyFetched = true;\n  }\n\n  /**\n   * Returns the linked list of assertions of the calling Node as an Array.\n   * @return {Array<Assertion>} The array of assertions.\n   */\n  getAssertions() {\n    const assertList = [];\n    let assert = this.assertions;\n\n    while (assert) {\n      assertList.push(assert);\n      assert = assert.nextAssertion;\n    }\n    return assertList;\n  }\n\n  /**\n   * Returns the linked list of inverse assertions of the calling Node as an\n   * Array.\n   * @return {Array<Assertion>} The array of Inverse assertions.\n   */\n  getInvAssertions() {\n    const invAssertList = [];\n\n    let invAssert = this.invAssertions;\n    while (invAssert) {\n      invAssertList.push(invAssert);\n      invAssert = invAssert.invNextAssertion;\n    }\n    return invAssertList;\n  }\n}\n\nNode.nodeHash = {}; // stores all created nodes\n\n/** Class representation of a single Assertion or triple in the KG. */\nclass Assertion {\n  /**\n   * The source or subject of the triple.\n   * @type {Node}\n   */\n  src;\n  /**\n   * The property label or predicate of the triple.\n   * @type {string}\n   */\n  property;\n  /**\n   * The provenance of the triple.\n   * @type {string}\n   */\n  provenance;\n  /**\n   * The target or object of the triple.\n   * @type {string|Node}\n   */\n  target;\n  /**\n   * The next Assertion object in a linked list representing the outgoing\n   * triples of the Node object stored in src property.\n   * @type {?Assertion}\n   */\n  nextAssertion;\n  /**\n   * The next Assertion object in a linked list representing the incoming\n   * triples of the Node object stored in src property.\n   * @type {?Assertion}\n   */\n  invNextAssertion;\n\n  /**\n   * Create a triple, setting the source's assertion prop to be the new object.\n   *\n   * @param {Node} src The source or subject of the triple.\n   * @param {string} property The property label of the triple.\n   * @param {Node|string} target The predicate or target of the triple.\n   * @param {string} provenance The provenance of the triple.\n   */\n  constructor(src, property, target, provenance) {\n    this.src = src;\n    this.property = property;\n    this.provenance = provenance;\n    this.target = target;\n    this.nextAssertion = src.assertions;\n    src.assertions = this;\n\n    if (target instanceof Object) {\n      this.invNextAssertion = target.invAssertions;\n      target.invAssertions = this;\n    }\n  }\n}\nexport {Node, Assertion};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Parses an mcf file and creates local knowledge graph of the parsed data\n * using Node and Assertion Class objects.\n */\n\nimport {Assertion, Node} from './graph.js';\nimport {shouldReadLine} from './utils.js';\nconst NAMESPACES = [ 'l', 'schema', 'dcs', 'dcid' ];\nconst LOCAL_NS = 'l';\n\n/** Class responsible for parsing an mcf file. */\nclass ParseMcf {\n  /**\n   * Provenance to be used for any Assertion objects created during parsing,\n   * based off of the mcf file name.\n   * @type {string}\n   */\n  prov;\n  /**\n   * Current subject Node for any Assertion created. Set when a 'Node:' property\n   * label is parsed.\n   * @type {Node}\n   */\n  curNode;\n  /**\n   * Current line number of the line being parsed, used for identifying location\n   * of syntax error in the mcf file.\n   * @type {number}\n   */\n\n  lineNum;\n  /**\n   * Create a ParseMcf object which keeps tracks of the current source node of\n   * each triple in the mcf and the provenance, which is the mcf file name.\n   * @param {string} fileFullName Name of file to be converted to a provenance\n   *     representing the file in teh Assertion Objects created while parsing.\n   */\n  constructor(fileFullName) {\n    let fileName = fileFullName;\n\n    // remove file extension to keep only filename as provenance\n    if (fileFullName.includes('.')) {\n      const fileNameSpiltOnPeriod = fileFullName.split('.');\n      fileNameSpiltOnPeriod.pop();\n      fileName = fileNameSpiltOnPeriod.join('.');\n    }\n    this.prov = 'local: ' + fileName;\n    this.curNode = null;\n    this.lineNum = -1;\n  }\n\n  /**\n   * Parses a string represetnaing a comma separated list of property values\n   * from a line of an mcf file. Returns a list having either a string or\n   * <namespace, reference> pair.\n   *\n   * @param {string} propValues A comma separated list of property values.\n   * @return {Array<(string|Object)>} Array of\n   *     parsed values.\n   */\n  parsePropValues(propValues) {\n    const values = [];\n    // split propValues on commas which are not enclosed by double quotes\n    for (const propValue of propValues.split(/,(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)) {\n      const namespace = propValue.split(':')[0].trim();\n      if (NAMESPACES.includes(namespace)) {\n        values.push({\n          'ns' : namespace,\n          'ref' : propValue.substring(propValue.indexOf(':') + 1).trim(),\n        });\n      } else{\n      values.push(propValue.trim());\n    }\n  }\n    return values;\n  }\n\n  /**\n   * Sets curNode variable of the calling ParseMcf object based on the passed in\n   * parsed values of a line of mcf, given the property label for the line was\n   * 'Node'. The parsed value either is a local reference with or without the\n   * 'l' namespace, or it has a remote namespace. If the namespace is remote,\n   * then the dcid for curNode is set. Updates localNodeHash mapping to store\n   * the subject nodes to be displayed in home screen of browser.\n   *\n   * @param {Array<string|Object>} parsedValues The array of parsed values from\n   *     a line of mcf with property label of 'Node'.\n   */\n  setCurNode(parsedValues) {\n    if (parsedValues.length !== 1) {\n      throw new Error('Error in declaring node (line ' + this.lineNum +\n                      '): ' + parsedValues.toString());\n    }\n\n    let nodeId = parsedValues[0];\n    let dcid = '';\n\n\n    if (parsedValues[0] instanceof Object) {\n      let ns = parsedValues[0]['ns'];\n      if (ns === 'dcid') {\n        dcid = parsedValues[0]['ref'];\n        nodeId = 'dcid:' + parsedValues[0]['ref'];\n      } else if (NAMESPACES.includes(ns)) {\n        throw new Error('Error with namespace in declaring node (line ' +\n          this.lineNum +  '): namespace: ' + parsedValues[0]['ns']);\n      }\n    }\n\n    this.curNode = Node.getNode(nodeId);\n    if (dcid) this.curNode.setDCID(dcid);\n\n    ParseMcf.localNodeHash[nodeId] = this.curNode;\n  }\n\n  /**\n   * Sets the dcid of the curNode variable of the calling ParseMcf object given\n   * the property label of the line being parsed is 'dcid'.\n   * @param {Array<string|Object>} parsedValues The array of parsed values from\n   *     a line of mcf with property label of 'dcid'.\n   */\n  setCurNodeDCID(parsedValues) {\n    const errStrEnding = '(line ' + this.lineNum +'): ' + parsedValues;\n    if (!this.curNode) {\n      throw new Error('ERROR (line ' + this.lineNum +'): ' +\n       'current node must be set before setting dcid');\n    }\n    if (parsedValues.length !== 1) {\n      throw new Error('ERROR (line ' + this.lineNum +'): ' +\n      'a node can only have one dcid');\n    }\n    if (typeof parsedValues[0] !== 'string') {\n      throw new Error('ERROR (line ' + this.lineNum +'): ' +\n      'dcid property must be a string, not a node reference');\n    }\n\n    this.curNode.setDCID(parsedValues[0].replace(/\"/g, ''));\n  }\n\n  /**\n   * Create Assertion objects using curNode variable of calling ParseMcf object\n   * as the source of the triple and the prov variable of the ParseMcf object\n   * as the provenance of the triple.One Assertion object is created for each\n   * parsed value given in the array parsedValues.\n   *\n   * @param {string} propLabel The property label of the triple to be created.\n   * @param {Array<string|Object>} parsedValues The parsed values from a line of\n   *     mcf, used to create the target for each created triple.\n   */\n  createAssertionsFromParsedValues(propLabel, parsedValues) {\n    for (const val of parsedValues) {\n      let target = val;\n      if (val instanceof Object) {\n        target = Node.getNode(val['ref']);\n        if (val['ns'] !== LOCAL_NS) {\n          target.setDCID(val['ref']);\n        }\n      }\n      new Assertion(this.curNode, propLabel, target, this.prov);\n    }\n  }\n\n  /**\n   * Parses a single line of an mcf file. First determines if the line should be\n   * read, then finds the property label, then the property values and creates\n   * an Assertion object based on the triple, given the calling object has a\n   * curNode property that acts as the source  and a prov property that gives\n   * the provenance for the triple.\n   *\n   * @param {string} line The line of mcf to be parsed.\n   */\n  parseLine(line) {\n    line = line.trim();\n\n    if (!shouldReadLine(line)) {\n      return;\n    } // not an error\n\n    if (!line.includes(':')) {\n      throw new Error('Error, line ' + this.lineNum + ' does not contain \":\"');\n    }\n\n    const propLabel = line.split(':', 1)[0].trim();\n    const propValues = line.substring(line.indexOf(':') + 1);\n\n    if (!propLabel || !propValues){\n      throw new Error('Error, (line ' + this.lineNum + '): ' + line);\n    }\n\n    // parsePropValues() returns a list having either a string or <namespace,\n    // reference> pair.\n    const parsedValues = this.parsePropValues(propValues);\n\n    switch (propLabel) {\n\n    case 'Node':\n      this.setCurNode(parsedValues);\n      break;\n\n    case 'dcid':\n      this.setCurNodeDCID(parsedValues);\n      break;\n\n    default:\n      this.createAssertionsFromParsedValues(propLabel, parsedValues);\n    }\n  }\n\n  /**\n   * Parses each line of the given string of an mcf file after setting the prov\n   * property of the calling ParseMcf object.\n   * @param {string} mcf The string representation of an mcf file to parse.\n   * @param {string} fileName The name of file that mcf string comes from.\n   * @return {Object} The mapping from local subject id to node, for home page.\n   */\n  parseMcfStr(mcf) {\n    const lines = mcf.split('\\n');\n    this.lineNum = 1;\n\n    lines.forEach((line) => {\n      this.parseLine(line);\n      this.lineNum++;\n    });\n\n    return ParseMcf.localNodeHash;\n  }\n\n  /**\n   * Reads an mcf file into a string, then creates ParseMcf object to parse the\n   * string.\n   * @param {FileObject} file An mcf file from the html file-input element.\n   * @return {Promise} Promise resolves to Node.nodeLocalHash after parsing mcf.\n   */\n  static readFile(file) {\n    const fileReader = new FileReader();\n    fileReader.readAsText(file);\n\n    return new Promise((res, rej) => {\n      fileReader.addEventListener('loadend', (result) => {\n        const mcfParser = new ParseMcf(file.name);\n        res(mcfParser.parseMcfStr(fileReader.result));\n      });\n\n      fileReader.addEventListener('error', rej);\n    });\n  }\n}\n\nParseMcf.localNodeHash = {}; // stores mapping of mcf subject IDs to the Node\n\nexport {ParseMcf};\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as csv from 'csvtojson';\n\nimport {shouldReadLine} from './utils.js';\n\n/**\n * Returns the string following '->' in  a given string. Used for getting csv\n * column name when filling in tmcf with values from csv.\n * Ex:   C:SomeDataset->GeoId would return 'GeoId'\n * @param {string} propValue The string to look for a column name in.\n * @return {string|null} The column name that comes after '->'.\n */\nfunction getArrowId(propValue) {\n  if (propValue.includes('->')) {\n    return propValue.split('->')[1];\n  }\n  return null;\n}\n\n/**\n * Returns a string matching the format E:'DataSet Name'->'Entity #'.\n * @param {string} line The string to look for a match in.\n * @return {string|null} The entity id that matches the specified format.\n */\nfunction getEntityID(line) {\n  const localIdMatch = line.match('E:(.*)->(.*)');\n  if (localIdMatch) {\n    return localIdMatch[0];\n  }\n  return null;\n}\n\n/**\n * Generates a local id for a node of specfic row in csv from an entity id used\n * in tmcf file.\n * Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n * @param {string} entityID The entity id used in tmcf file.\n * @param {string} index The row number in the csv of the node to be created.\n * @return {string|null} The local id for the node of the specific csv row.\n */\nfunction getLocalIdFromEntityId(entityID, index) {\n  if (entityID) {\n    return entityID.replace('->', '_').replace('E:', '') + '_R' + index;\n  }\n  return null;\n}\n\n/**\n * Converts propertyValues from a line of tmcf to mcf by either converting\n * entity ids to local ids or replacing a csv column reference with the actual\n * value from the csv.\n *\n * @param {string} propValues The property values from the line of TMCF.\n * @param {Object} csvRow The JSON representation of a single row of a csv file.\n *     The keys are the column names and values are the corresponding entries of\n *     the csv for the specfic row/column.\n * @param {number} index The row number of the csvRow, used to generate a local\n *     id if needed.\n * @return {string} The mcf version of the given propValues which has local ids\n *     in lieu of entity ids and csv column references replaces with csv values.\n */\nfunction parsePropertyValues(propValues, csvRow, index) {\n  const parsedValues = [];\n\n  for (const propValue of propValues.split(',')) {\n    let parsedValue = propValue;\n\n    const entityID = getEntityID(propValue);\n\n    // convert entity id format to local id format\n    // Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n    if (entityID) {\n      const localId = getLocalIdFromEntityId(entityID, index);\n      parsedValue = parsedValue.replace(entityID, localId);\n    } else {\n      // Replace csv column placeholder with the value\n      const colName = getArrowId(propValue);\n      parsedValue = parsedValue.replace(/C:(.*)->(.*)/, csvRow[colName]);\n    }\n    parsedValues.push(parsedValue);\n  }\n  return parsedValues.join(',');\n}\n\n/**\n * Convert a row of csv to mcf using the tmcf as a template.\n * @param {string} template The string representation of tmcf file.\n * @param {Object} csvRow The JSON representation of a single row of a csv file.\n *     The keys are the column names and values are the corresponding entries of\n *     the csv for the specfic row/column.\n * @param {number} index The row number of the csvRow, used to generate a local\n *     id if needed.\n * @return {string} The constructed mcf for the single row from csv file.\n */\nfunction fillTemplateFromRow(template, csvRow, index) {\n  const filledTemplate = [];\n  for (const line of template.split('\\n')) {\n    if (!line.trim()) {\n      filledTemplate.push('');\n      continue;\n    }\n\n    if (!shouldReadLine(line)) {\n      continue;\n    }\n\n    const propLabel = line.split(':')[0];\n    const propValues = line.replace(propLabel + ':', '').trim();\n\n    const parsedValues = parsePropertyValues(propValues, csvRow, index);\n\n    filledTemplate.push(propLabel + ': ' + parsedValues);\n  }\n  return filledTemplate.join('\\n');\n}\n\n/**\n * Creates an mcf string from a string representation of TMCF file and the json\n * representation of a CSV file. The tmcf is populated with csv files for each\n * row of the csv.\n * @param {string} template The string representation of a tmcf file.\n * @param {Array<Object>} csvRows The json representation of the csv file. Each\n *     Object element of the array represents one row of the csv.\n * @return {string} The created mcf as a string.\n */\nfunction csvToMCF(template, csvRows) {\n  let index = 1;\n  const mcfStrList = [];\n  for (const row of csvRows) {\n    mcfStrList.push(fillTemplateFromRow(template, row, index));\n    index += 1;\n  }\n  return mcfStrList.join('\\n');\n}\n\n/**\n * Converts CSV file to an array of JS Object where each JS Object in the array\n * represents one row of the csv. The keys of the object are the column header\n * names and the values of the object are the csv entries in that column of the\n * given row the object represents.\n * @param {string} template The string representation of a tmcf file.\n * @param {FileObject} csvFile THe csv file from html file-input element.\n * @return {Array<Object>} The json representation of the csv file.\n */\nasync function readCSVFile(template, csvFile) {\n  const fileReader = new FileReader();\n  fileReader.readAsText(csvFile);\n  return new Promise((res, rej) => {\n    fileReader.addEventListener('loadend', (result) => {\n      csv().fromString(fileReader.result).then((csvRows) => {\n        console.log('csvFile: ' + csvFile.name);\n        const mcf = csvToMCF(template, csvRows);\n        res(mcf);\n      });\n    });\n    fileReader.addEventListener('error', rej);\n  });\n}\n\n/**\n * Reads a tmcf file and returns the contents as a string\n * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n * @return {string} The string representation of the tmcf file.\n */\nasync function readTMCFFile(tmcfFile) {\n  const fileReader = new FileReader();\n  fileReader.readAsText(tmcfFile);\n  return new Promise((res, rej) => {\n    fileReader.addEventListener('loadend',\n                                (result) => { res(fileReader.result); });\n    fileReader.addEventListener('error', rej);\n  });\n}\n\n/**\n * Converts a TMCF file and CSV file to an MCF string.\n * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n * @param {FileObject} csvFile THe csv file from html file-input element.\n * @return {string} The translated mcf as a string.\n */\nasync function tmcfCSVToMCF(tmcfFile, csvFile) {\n  return readTMCFFile(tmcfFile).then((template) =>\n                                         readCSVFile(template, csvFile));\n}\n\nexport {\n  tmcfCSVToMCF,\n  csvToMCF,\n  fillTemplateFromRow,\n  getLocalIdFromEntityId,\n  getEntityID,\n  getArrowId,\n  parsePropertyValues,\n};\n","import {Node} from './graph.js';\nimport {ParseMcf} from './parse-mcf.js';\nimport * as ParseTMCF from './parse-tmcf.js';\n\n/**\n * Parses App state's fileList to find either one mcf file or one set of\n * tmcf+csv. Parses the files according to their file type.\n * @param {Array<FileBlob>} fileList The list of files to load into memory.\n * @return {Array<string>} An array of local ids from Node.nodeLocalHash.\n */\nasync function readFileList(fileList) {\n  let tmcfFile;\n  let csvFile;\n  let mcfFile;\n  for (const file of fileList) {\n    if (file.name.endsWith('.tmcf')) {\n      tmcfFile = file;\n    } else if (file.name.endsWith('.mcf')) {\n      mcfFile = file;\n    } else {\n      csvFile = file;\n    }\n  }\n\n  if (mcfFile) {\n    return ParseMcf.readFile(mcfFile).then((localHash) =>\n                                               Object.keys(localHash));\n  }\n\n  if (tmcfFile && csvFile) {\n    return ParseTMCF.tmcfCSVToMCF(tmcfFile, csvFile)\n        .then((mcf) => {\n          console.log(mcf);\n          const mcfParser = new ParseMcf(tmcfFile.name);\n          return mcfParser.parseMcfStr(mcf);\n        })\n        .then((localHash) => Object.keys(localHash));\n  }\n  return [];\n}\n\nfunction clearFiles() {\n  Node.nodeHash = {};\n  ParseMcf.localNodeHash = {};\n}\n\nfunction retrieveNode(id, shouldCreateRemote) {\n  const foundNode = Node.getNode(id, true);\n  // should make dcid from search bar\n  if (shouldCreateRemote && !(foundNode.dcid)) {\n    foundNode.setDCID(id);\n  }\n  console.log('retrieve');\n  console.log(foundNode);\n  return foundNode;\n}\n\nfunction isNodeObj(obj) { return Node.isNode(obj); }\n\nasync function getClassName(target) {\n  if (!target) {\n    return null;\n  }\n  if (target.existsInKG) {\n    return 'clickable-blue';\n  }\n\n  return target.setExistsInKG().then(() => {\n    console.log(target);\n    if (target.existsInKG) {\n      return 'clickable-blue';\n    }\n\n    if (!target.dcid && target.localId &&\n        target.localId in ParseMcf.localNodeHash) {\n      return 'clickable-purple';\n    }\n\n    if (!target.dcid && !(target.localId in ParseMcf.localNodeHash)) {\n      return 'clickable-orange';\n    }\n    return 'clickable-red';\n  });\n}\n\nfunction localNodeHashExists() {\n  return (ParseMcf.localNodeHash) ? true : false;\n}\nexport {\n  readFileList,\n  clearFiles,\n  retrieveNode,\n  isNodeObj,\n  getClassName,\n  localNodeHashExists,\n};\n","import * as API from './back-end/server-api.js';\n\nlet fileHash ='#';\n/**\n * Sets the window hash value to query a given id.\n * @param {string} id The id of the desired node to display. This can be either\n *     a dcid or a local id.\n */\nfunction goToId(id) {\n  if(id.includes('dcid:')){\n  window.location.hash = fileHash + '&dcid=' + id.replace('dcid:', '');\n} else if (API.localNodeHashExists()){\n  window.location.hash = fileHash + '&id=' + id;\n} else{\n  window.location.hash = fileHash + '&error=noLocalFiles';\n}\n}\n\n/**\n * Sets the window hash value to empty to redirect user to home page.\n */\nfunction goToHome() {\n  console.log(fileHash)\n  window.location.hash = fileHash;\n}\n\nfunction setFileHash(fileUrlList){\n  fileHash = '#'\n  for (const fileUrl of fileUrlList){\n    fileHash += '&file=' + fileUrl;\n  }\n}\nexport {goToId, goToHome, setFileHash};\n","import React, {Component} from 'react';\nimport * as utils from './utils.js';\nimport './App.css';\n\n/** Header component contains the id search bar and return home button. */\nclass Header extends Component {\n  /**\n   * Calls utils method goToId to search for an id when the user presses enter.\n   * @param {Event} event OnKeyUp  event from html search input element.\n   */\n  handleSearch(event) {\n    if (event.keyCode === 13) {\n      utils.goToId(event.target.value);\n    }\n  }\n  /** Renders header element. */\n  render() {\n    return (\n      <div className='header'>\n        <button onClick = {() => utils.goToHome() }>Return Home</button>\n        <input type=\"search\" onKeyUp={this.handleSearch}\n          placeholder=\"Search id, use 'dcid:' namespace for remote lookup...\" />\n      </div>\n    );\n  }\n}\nexport {Header};\n","import React, {Component} from 'react';\nimport './App.css';\nimport * as API from './back-end/server-api.js';\nimport * as utils from './utils.js';\n\n/**\n * Returns an html element of the missing cell value in a triple. If the current\n * triple is an outgoing assertion (current node displayed is the source of the\n * triple) then this method will be called on the target. If the current triple\n * is an inverse assertions, then this method is called on the source of the\n * triple.\n * Determines if the target is another node and should be\n * clickable, what color it should be, and the node reference that should be\n * displayed (dcid vs dcid [l:localId] vs [l:localId]). If the target is not\n * another node, then an html element of pure text is returned.\n * @param {Node|string} target The source of an inverse assertion or the target\n *     of a direct assertion.\n * @return {HtmlElement} A single cell of an html row representing a triple.\n *     Either the source or target of the triple depending if the triple is\n *     inverse or not.\n */\nasync function getMissingVal(target) {\n  if (API.isNodeObj(target)) {\n    const className = await API.getClassName(target);\n    return (\n      <td className={className} onClick={() =>\n        utils.goToId(target.localId)}>{target.getRef()}</td>\n    );\n  }\n  return (<td >{target}</td>);\n}\n\n/**\n * Returns an html element row representing the given assertion.\n * @param {Assertion} assert The assertion/triple to create the html row from.\n * @param {boolean} isInverse True if the assertion is inverse, meaning the\n *     currently displayed node is the target of the triple.\n * @param {number} index Used to create a unique key for the html row element.\n * @return {HtmlElement} A row represeting the given triple.\n */\nasync function getRowFromTriple(assert, isInverse, index ) {\n  const missingVal = isInverse ? assert.src : assert.target;\n  const val = await getMissingVal(missingVal);\n\n  const className = assert.provenance.startsWith('local:') ? 'bold' : null;\n  return (\n    <tr className={className} key={assert.property + index}>\n      <td>{assert.property}</td>\n      {val}\n      <td>{assert.provenance.replace('local:', '')}</td>\n    </tr>\n  );\n}\n\n/**\n * Converts a list of Assertion objects to an array of HTML row elements that is\n * displyed in the TriplesTable.\n * @param {Array<Assertion>} asserts An array of Assertion objects to display in\n *     the TriplesTable component.\n * @param {boolean} isInverse True if the current node displayed is the target\n *     for each of the assertions.\n * @return {Array<HtmlElement>} The array of HTML row elements representing each\n *     triple.\n */\nasync function getTripleRows(asserts, isInverse) {\n  const tripleRows = [];\n  let index = 0; // used to create a unique key for each row element\n\n  for (const assert of asserts) {\n    const tripleRow = await getRowFromTriple(assert, isInverse, index);\n    tripleRows.push(tripleRow);\n    index += 1;\n  }\n  return tripleRows;\n}\n\nfunction getTableHeaders(isInverse) {\n  if (isInverse) {\n    return (\n      <tr>\n        <th>Property</th>\n        <th>Source</th>\n        <th>Provenance</th>\n      </tr>\n    );\n  }\n  return (\n    <tr>\n      <th>Property</th>\n      <th>Target</th>\n      <th>Provenance</th>\n    </tr>\n  );\n}\n\n/** Displays all given triples as a table */\nexport class TriplesTable extends Component {\n  /** Creates TriplesTable component. */\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      tableRows: null,\n      loading: true,\n    };\n  }\n\n  /**\n   * Gets rows of triples when the array of Assertions from props is updated.\n   * @param {Object} prevProps The previous props before the component updated,\n   *     used to compare if the passed in triples have been modified.\n   */\n  componentDidUpdate(prevProps) {\n    if (prevProps.triples !== this.props.triples) {\n      this.setState({loading: true});\n      getTripleRows(this.props.triples, this.props.inverse).then((rows) => {\n        this.setState({tableRows: rows, loading: false});\n      });\n    }\n  }\n\n  /** Renders TriplesTable component.   */\n  render() {\n    if (this.state.loading) return null;\n\n    const tableHeaders = getTableHeaders(this.props.inverse);\n\n    return (\n      <table>\n        <thead>\n          {tableHeaders}\n        </thead>\n        <tbody>{this.state.tableRows}</tbody>\n      </table>\n    );\n  }\n}\n","import * as API from './back-end/server-api.js';\nimport React, {Component} from 'react';\nimport {Header} from './Header.js';\nimport {TriplesTable} from './TriplesTable.js';\nimport './App.css';\n\n/** Displays node data for a given node passed in through props. */\nclass DisplayNode extends Component {\n  /** Creates DisplayNode component. */\n  constructor(props) {\n    super(props);\n    this.state = {\n      ref: null,\n      asserts: [],\n      invAsserts: [],\n      fetching: true,\n    };\n  }\n\n  /** Sets node data when the component mounts. */\n  componentDidMount() {\n    this.setNodeData();\n  }\n\n  /**\n   * Sets node data when the node to display changes.\n   * @param {Object} prevProps The previous props before the component updated,\n   *     used to compare if the passed in node has changed.\n   */\n  componentDidUpdate(prevProps) {\n    if (prevProps.node !== this.props.node) {\n      this.setNodeData();\n    }\n  }\n\n  /**\n   * Loads data to display for the node passed in through props. This includes\n   * fetching the remote data from DC KG for the node.\n   */\n  setNodeData() {\n    console.log(this.props.node);\n\n    const curNode = this.props.node;\n    this.setState({ref: curNode.getRef(), fetching: true});\n\n    API.getClassName(curNode)\n        .then((className) => this.setState({className: className}) );\n\n    curNode.fetchRemoteData().then( () => {\n      this.setState({fetching: false});\n     const assertList = curNode.getAssertions();\n     this.setState({asserts: assertList});\n     const invAssertList = curNode.getInvAssertions();\n     this.setState({invAsserts: invAssertList});\n    });\n  }\n\n  /** Renders the DisplayNode component. */\n  render() {\n    let table;\n    if (this.state.fetching) {\n      table = (\n        <div>\n          <br></br>\n          <h1 className='normal'>...fetching triples...</h1>\n        </div>\n      );\n    } else {\n      table = (\n        <div className='node'>\n          <h3 className='inline'>Assertions</h3>\n          <p className='inline'> - current node is source</p>\n          <TriplesTable triples={this.state.asserts} inverse={false}/>\n          <br></br>\n          <h3 className='inline'>Inverse Assertions</h3>\n          <p className='inline'> - current node is target</p>\n          <TriplesTable triples={this.state.invAsserts} inverse={true}/>\n        </div>\n      );\n    }\n\n    return (\n      <div>\n        <h1 className=\n          {this.state.className}>Currently Viewing: {this.state.ref}</h1>\n        {table}\n        <br></br>\n        <p className='clickable-blue'>Node has dcid and dcid exists in KG</p>\n        <p className='clickable-purple'>Node has resolved local reference and no dcid</p>\n        <p className='clickable-orange'>Node has no dcid and local reference is unresolved</p>\n        <p className='clickable-red'>Anything else (has dcid, but does not exist in KG)</p>\n      </div>\n    );\n  }\n}\nexport default DisplayNode;\n","import React, {Component} from 'react';\nimport './App.css';\nimport * as API from './back-end/server-api.js';\nimport * as utils from './utils.js';\nimport {Header} from './Header.js';\nimport DisplayNode from './DisplayNode.js';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      subjNodes: [],\n      curNode: null,\n      fileList: [],\n      loading: null,\n      fileHash: '',\n      firstLoad: true,\n      searchErrMsg: '',\n    };\n  }\n  /** Adds an event listener to the window to respond to url hash changes. */\n  componentDidMount() {\n    window.addEventListener('hashchange', () => this.handleHashChange(), false);\n    if(this.state.firstLoad){\n      console.log('first app load')\n      this.loadUrlFiles();\n      this.setState({firstLoad:false});\n    }\n  }\n\n  loadUrlFiles(){\n    const params = new URLSearchParams(window.location.hash.split('#')[1]);\n\n    // get path to file(s) from urls\n    const fileUrls = params.getAll('file');\n    if (!fileUrls.length) return;\n\n    this.getRemoteFile(0, fileUrls);\n\n    utils.setFileHash(fileUrls);\n    // get node to display from url\n    let node;\n    const searchDCId = params.get('dcid');\n    if (searchDCId) {\n       node = API.retrieveNode(searchDCId, /* shouldCreateRemote */ true);\n     this.setState({curNode: node});\n      console.log(node)\n    }\n\n  }\n\n  /**\n   * Sets App state according to url parameters 'id' and 'file'. The param 'id'\n   * will cause the display node page to appear with the node of the specified\n   * id. The 'file' param followed by url to a file will cause that file to be\n   * loaded and parsed if it is one url to mcf or two 'file' params with one a\n   * url to a tmcf and the other a url to a csv file.\n   */\n  handleHashChange() {\n    const params = new URLSearchParams(window.location.hash.split('#')[1]);\n    // get node to display from url\n\n    let searchId = params.get('id');\n    let shouldCreateRemote = false;\n    if (!searchId) {\n      searchId = params.get('dcid');\n      shouldCreateRemote = true;\n    }\n\n    let node = null;\n    if (searchId) {\n       node = API.retrieveNode(searchId, shouldCreateRemote);\n    }\n    this.setState({curNode: node});\n\n    const err = params.get('error');\n    console.log(err)\n    let errMsg = '';\n    if( err === 'noLocalFiles'){\n      console.log('errMsg')\n       errMsg = 'Use dcid namespace if searching for remote node or '\n        + 'load a file to search for a local id.'\n    } else if(err){\n      errMsg = 'Error occured in search. Verify node you are trying to find.'\n    }\n    this.setState({searchErrMsg: errMsg});\n  }\n\n  /**\n   * Gets a remote file from an Array of urls at index i and appends the\n   * retrieved file to App state's fileList. This is a recursive method that\n   * calls itself to iterate through the entire Array of fileUrls.\n   * @param {number} i The index of the url to get from fileUrls array.\n   * @param {Array<string>} fileUrls The array of file urls to load and append\n   *     to App state's fileList.\n   */\n  getRemoteFile(i, fileUrls) {\n    if (i >= fileUrls.length) {\n      this.submitFileList();\n      return;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'blob';\n    xhr.open('GET', fileUrls[i]);\n    console.log('loading: ' + fileUrls[i]);\n    xhr.onload = () => {\n      console.log('finished loading');\n      console.log(xhr.response);\n      const fileUrl = new URL(fileUrls[i])\n      xhr.response.name=fileUrl.pathname;\n      this.setState({fileList: this.state.fileList.concat(xhr.response)});\n      this.getRemoteFile(i+1, fileUrls);\n    };\n    xhr.send();\n  }\n\n  /**\n   * Passes App state's fileList array to the 'back-end' API to be parsed and\n   * the files loaded into memory.\n   */\n  submitFileList() {\n    this.setState({loading: <h1>...loading mcf...</h1>});\n\n    API.readFileList(this.state.fileList)\n        .then( (subjList) => {\n          this.setState({subjNodes: subjList, loading: null})\n          this.handleHashChange();\n        });\n  }\n\n  /**\n   * Clear App state and calls the 'back-end' API clearFiles method.\n   */\n  onClearPress() {\n    this.setState({subjNodes: [], fileList: [], loading: null});\n    API.clearFiles();\n  }\n  /** Renders the browser by displaying a specific node or the homepage. */\n  render() {\n\n    let display;\n    if (this.state.curNode) {\n      display =  (\n      \t<DisplayNode node={this.state.curNode} />\n      );\n    } else{\n      display = (\n        <div className='Home'>\n        <h3>{this.state.searchErrMsg}</h3>\n        <div className='div-row'>\n\n          <div id='curFiles'>\n          <h3>Current Files:</h3>\n          <ul>{this.state.fileList.map( (file) =>\n            <li key={file.name}>{file.name}</li>,\n          )}</ul>\n          <br></br>\n          <button onClick={() => this.onClearPress()} >Clear</button>\n          <br></br>\n          <h3>Subject Nodes:</h3>\n          <ul>{this.state.subjNodes.map( (dcid) =>\n            <li key={dcid} onClick={() => utils.goToId(dcid)}>{dcid}</li>,\n          )}</ul>\n          {this.state.loading}\n      </div>\n\n          <div id='uploadFiles'>\n            <h3>Upload one MCF file or one set of TMCF+CSV files to preview in Data Commons.</h3>\n            <div>\n          <input id=\"file-select\" onChange={ (event) =>{\n              this.setState({fileList: this.state.fileList.concat(Array.from(event.target.files))})\n            } }\n            type=\"file\" name=\"UploadFile\" accept=\".mcf,.tmcf,.csv\" required multiple />\n            <button onClick={() => this.submitFileList()} >Submit</button>\n            </div>\n          </div>\n              </div>\n        </div>\n      )\n    }\n\n    return (\n      <div className=\"App\">\n        <Header />\n        {display}\n      </div>\n\n    );\n  }\n}\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n"],"sourceRoot":""}