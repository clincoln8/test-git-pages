{"version":3,"sources":["back-end/graph.js","back-end/utils.js","back-end/parse-mcf.js","back-end/parse-tmcf.js","back-end/server-api.js","utils.js","Header.js","TriplesTable.js","DisplayNode.js","App.js","index.js"],"names":["API_ROOT","getLabelsTargetUrl","dcid","getValuesTargetUrl","label","out","targetUrl","getRemotePropertyLabels","a","fetch","then","res","json","data","JSON","parse","payload","getRemotePropertyValues","triples","console","log","in","getValueFromValueObj","valueObj","value","Node","getNode","setDCID","existsInKG","id","this","localID","alreadyFetched","remote","nodeHash","mergeNode","dcidToLocal","absorbedNode","aquiredAsserts","getAssertions","assert","src","nextAssertion","assertions","aquiredInvAsserts","getInvAssertions","invAssert","target","nextInvAssertion","invAssertions","dcidRef","localRef","url","curNode","allLabels","outLabels","valueList","Assertion","addAssertion","provenanceId","inLabels","source","assertList","push","invAssertList","invNextAssertion","obj","shouldCreate","existing","newNode","nodeLocalHash","property","provenance","Object","shouldReadLine","line","startsWith","length","NAMESPACES","ParseMCF","prov","parsedValues","propLabel","val","utils","trim","includes","substring","indexOf","propValues","parsePropValues","handleNodeValue","replace","createAssertionsFromValues","mcf","fileFullName","fileNameSpiltOnPeriod","split","pop","fileName","join","lines","parseLine","values","propValue","namespace","file","fileReader","FileReader","readAsText","Promise","rej","addEventListener","result","mcfParser","parseMCFStr","name","csv","require","getArrowId","getEntityID","localIDMatch","match","getLocalIDFromEntityID","entityID","index","parsePropertyValues","csvRow","parsedValue","colName","fillTemplateFromRow","template","filledTemplate","csvToMCF","csvRows","mcfStrList","row","readCSVFile","csvFile","fromString","readTMCFFile","tmcfFile","tmcfCSVToMCF","fileList","endsWith","mcfFile","readFile","localHash","keys","ParseTMCF","retrieveNode","shouldCreateRemote","foundNode","isNodeObj","isNode","getClassName","setExistsInKG","goToId","window","location","hash","Header","event","keyCode","className","type","onKeyUp","handleSearch","placeholder","onClick","Component","getMissingVal","API","getRef","getRowFromTriple","isInverse","missingVal","key","asserts","tripleRows","tripleRow","TriplesTable","props","state","tableRows","loading","prevProps","setState","getTripleRows","inverse","rows","tableHeaders","DisplayNode","ref","invAsserts","fetching","setNodeData","node","fetchRemoteData","tables","App","subjNodes","handleHashChange","params","URLSearchParams","searchDCId","get","searchId","fileUrls","getAll","getRemoteFile","i","xhr","XMLHttpRequest","responseType","open","onload","response","concat","send","subjList","onChange","Array","from","files","accept","required","multiple","map","submitFileList","onClearPress","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fffa1537.chunk.js","sourcesContent":["/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst API_ROOT = 'https://api.datacommons.org';\n\n/**\n * Generates the url to get property labels for a dcid using DC REST API.\n *\n * @param {string} dcid The dcid to find property labels for.\n * @return {string} The generated url.\n */\nfunction getLabelsTargetUrl(dcid) {\n  const targetUrl = (API_ROOT + '/node/property-labels?dcids=' + dcid);\n  return targetUrl;\n}\n\n/**\n * Generates the url to get property values from the DC KG using REST API.\n *\n * @param {string} dcid The dcid of the node to get the property values for.\n * @param {string} label The property label to query for.\n * @param {boolean} out The direction of label, true indicates outgoing label.\n * @return {string} The generated url.\n */\nfunction getValuesTargetUrl(dcid, label, out) {\n  let targetUrl = (API_ROOT + '/node/property-values?dcids=' + dcid +\n                   '&property=' + label + '&direction=');\n  if (out) {\n    targetUrl += 'out';\n  } else {\n    targetUrl += 'in';\n  }\n  targetUrl += '&limit=500';\n  return targetUrl;\n}\n\n/**\n * Gets all property labels of the given dcid that are in the DC KG.\n *\n * @param {string} dcid The dcid of the node to find property labels for.\n * @return {Object} An object containing both 'in' and 'out' property labels.\n */\nasync function getRemotePropertyLabels(dcid) {\n  const targetUrl = getLabelsTargetUrl(dcid);\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid]);\n}\n\n/**\n * Gets all property values containing the given dcid, property label, and\n * direction.\n *\n * @param {string} dcid The dcid of the node to find property value for.\n * @param {string} label The property label to query for.\n * @param {boolean} out The direction of label, true indicates outgoing label.\n * @return {Object} An object containing all found values matching the query.\n */\nasync function getRemotePropertyValues(dcid, label, out) {\n  const targetUrl = getValuesTargetUrl(dcid, label, out);\n  return fetch(targetUrl)\n      .then((res) => res.json())\n      .then((data) => JSON.parse(data.payload)[dcid])\n      .then((triples) => {\n        console.log('url: ' + targetUrl + ', values: ' + triples);\n        if (out) {\n          return triples.out;\n        } else {\n          return triples.in;\n        }\n      });\n}\n\n/**\n * Parses an Object returned from the DC REST get_values API to create a Node\n * object from the value's dcid or to return the string value that the object\n * holds.\n *\n * @param {Object} valueObj An object returned from DC REST get_values API.\n * @return {Node | string} The created Node if the value obj has a dcid,\n *     otherwise the string of the value.\n */\nfunction getValueFromValueObj(valueObj) {\n  let value;\n  if ('dcid' in valueObj) {\n    value = Node.getNode(valueObj.dcid, true);\n    value.setDCID(valueObj.dcid)\n    value.existsInKG = true;\n  } else if ('value' in valueObj) {\n    value = valueObj.value;\n  } else {\n    console.log('ERROR remote fetch no dcid or value prop: ' + valueObj);\n  }\n  return value;\n}\n\n/** Class representation of a single Node in the KG. */\nclass Node {\n  /**\n   * Create a Node based on a given id.\n   * @param {string} id The id of the node to find.\n   * @param {boolean} isDCID True if the given id is a dcid.\n   */\n  constructor(id) {\n    this.localID = id;\n    this.alreadyFetched = false;\n    this.existsInKG = false;\n    this.dcid = null;\n  }\n\n  /**\n   * Indicates if a given object is an instance of Node class.\n   * @param {Object} obj The object to check.\n   * @return {boolean} True if the object is an instance of Node.\n   */\n  static isNode(obj) {\n    return obj instanceof Node;\n  }\n\n  /**\n   * Returns a node with the given ID, creates a new node if shouldCreate is\n   * true, or null if the node does not exist and a node should not be created.\n   *\n   * @param {string} id The id of the node to find.\n   * @param {boolean} shouldCreate True if a new Node should be created if it\n   *     does not already exist.\n   * @return {Node|null} The found node if it exists or is created.\n   */\n  static getNode(id, shouldCreate) {\n    let existing;\n\n    // check if the id can be converted to localID\n    existing = Node.nodeHash[Node.dcidToLocal[id]];\n    if (existing) {\n      return existing;\n    }\n\n    // check if id is in node hash already (cache)\n    existing = Node.nodeHash[id];\n    if (existing) {\n      return existing;\n    }\n\n    if (shouldCreate) {\n      const newNode = new Node(id);\n      Node.nodeHash[id] = newNode;\n      return newNode;\n    }\n    return null;\n  }\n\n  /**\n   * Sets the dcid of Node object and adds the dcid to localId mapping to\n   * Node.dcidToLocal\n   *\n   * @param {string} dcid The dcid to be added to the Node object.\n   */\n  setDCID(dcid) {\n    const remote = Node.nodeHash[dcid];\n    if (remote) {\n      this.mergeNode(remote);\n    }\n    this.dcid = dcid;\n    Node.dcidToLocal[dcid] = this.localID;\n    Node.nodeHash[dcid] = this;\n  }\n\n\n//TODO fix + test\n  /**\n   * Moves the assertions and invAssertions from the given param node to the\n   * calling Node object by changing the src property for assertions and the\n   * target property of the invAssertions.\n   *\n   * @param {Node} absorbedNode The node object whose triples should be copied.\n   */\n  mergeNode(absorbedNode) {\n    if (this.localID === absorbedNode.localID) return;\n    console.log('called merge')\n    const aquiredAsserts = absorbedNode.getAssertions();\n    for (const assert of aquiredAsserts) {\n      assert.src = this;\n      assert.nextAssertion = this.assertions;\n      this.assertions = assert;\n    }\n\n    const aquiredInvAsserts = absorbedNode.getInvAssertions();\n    for (const invAssert of aquiredInvAsserts) {\n      invAssert.target = this;\n      invAssert.nextInvAssertion = this.invAssertions;\n      this.invAssertions = invAssert;\n    }\n  }\n\n  /**\n   * Returns the reference to the node that is displayed in browser. If the\n   * node has a dcid, then the dcid will be displayed. If the node's local id\n   * is different, then the local id is also displayed.\n   * Ex: <dcid> [l:<localId>]\n   * @return {string} The reference to the node to be displayed.\n   */\n  getRef() {\n    let dcidRef = '';\n\n    let localRef = '';\n\n    if (this.dcid) {\n      dcidRef = this.dcid;\n    }\n\n    if (!this.dcid || this.dcid !== this.localID) {\n      localRef = '[l:' + this.localID + ']';\n    }\n\n    return dcidRef + ' ' + localRef;\n  }\n\n\n  /**\n   * Sets the property existsInKG to true if the Node has triples in the DC KG.\n   */\n  async setExistsInKG() {\n    if (!this.dcid || this.existsInKG) {\n      return;\n    }\n\n    const url = API_ROOT + '/node/triples?dcids=' + this.dcid + '&limit=1';\n    const curNode = this;\n\n    return fetch(url).then((res) => res.json()).then((data) => {\n      if (JSON.parse(data.payload)[curNode.dcid]) {\n        curNode.existsInKG = true;\n      }\n    });\n  }\n\n  /**\n   * Stores remote triples as assertions and invAssertions of the calling Node\n   * object. Sets the alreadyFetched property to true if data is fetched.\n   */\n  async fetchRemoteData() {\n    const curNode = this;\n\n    if (curNode.alreadyFetched || !curNode.dcid) {\n      return;\n    }\n\n    await getRemotePropertyLabels(curNode.dcid).then(async (allLabels) => {\n      // create Assertions for each triple current node is source\n      for (const label of allLabels.outLabels) {\n        await getRemotePropertyValues(curNode.dcid, label, true)\n            .then((valueList) => {\n              if (!valueList) {\n                console.log('ERROR: could not find value for node: ' +\n                            curNode.dcid + ', label: ' + label);\n                return;\n              }\n              for (const valueObj of valueList) {\n                const target = getValueFromValueObj(valueObj);\n                Assertion.addAssertion(curNode, label, target,\n                    valueObj.provenanceId);\n              }\n            });\n      }\n\n      // create Inverse Assertion for each triple current node is target\n      for (const label of allLabels.inLabels) {\n        await getRemotePropertyValues(curNode.dcid, label, false)\n            .then((valueList) => {\n              for (const valueObj of valueList) {\n                const source = getValueFromValueObj(valueObj);\n                Assertion.addAssertion(source, label, curNode,\n                    valueObj.provenanceId);\n              }\n            });\n      }\n    });\n    curNode.alreadyFetched = true;\n  }\n\n  /**\n   * Returns the linked list of assertions of the calling Node as an Array.\n   * @return {Array<Assertion>} The array of assertions.\n   */\n  getAssertions() {\n\n    const assertList = [];\n    let assert = this.assertions;\n\n    while (assert) {\n      assertList.push(assert);\n      assert = assert.nextAssertion;\n    }\n    return assertList;\n  }\n\n  /**\n   * Returns the linked list of inverse assertions of the calling Node as an\n   * Array.\n   * @return {Array<Assertion>} The array of Inverse assertions.\n   */\n  getInvAssertions() {\n    const invAssertList = [];\n\n    let invAssert = this.invAssertions;\n    while (invAssert) {\n      invAssertList.push(invAssert);\n      invAssert = invAssert.invNextAssertion;\n    }\n    return invAssertList;\n  }\n}\n\nNode.nodeLocalHash = {}; // stores mapping of mcf local subject IDs to the Node\nNode.dcidToLocal = {}; // stores mapping of dcids to local id equivalents\nNode.nodeHash = {}; // stores all created nodes\n\n/** Class representation of a single Assertion (triple) in the KG. */\nclass Assertion {\n  /**\n   * Create a triple, setting the source's assertion prop to be the new object.\n   *\n   * @param {Node} src The source or subject of the triple.\n   * @param {string} property The property label of the triple.\n   * @param {Node|string} target The predicate or target of the triple.\n   * @param {string} provenance The provenance of the triple.\n   */\n  constructor(src, property, target, provenance) {\n    this.src = src;\n    this.property = property;\n    this.provenance = provenance;\n    this.target = target;\n    this.nextAssertion = src.assertions;\n    src.assertions = this;\n\n    if (target instanceof Object) {\n      this.invNextAssertion = target.invAssertions;\n      target.invAssertions = this;\n    }\n  }\n\n  /**\n   * Creates a new Assertion object given the params.\n   * @param {Node} src The source or subject of the triple.\n   * @param {string} property The property label of the triple.\n   * @param {Node|string} target The predicate or target of the triple.\n   * @param {string} provenance The provenance of the triple.\n   */\n  static addAssertion(src, property, target, provenance) {\n    return (new Assertion(src, property, target, provenance));\n  }\n}\nexport {\n  Assertion,\n  Node,\n  getRemotePropertyLabels,\n  getRemotePropertyValues,\n  getValueFromValueObj,\n};\n","/**\n     * Indicates if a line should be parsed.\n     * @param {string} line The line to be checked.\n     * @return {boolean} False if the line is a comment or empty, otherwise\n     *     true.\n     */\nfunction shouldReadLine(line) {\n  if (line.startsWith('//') || line.length === 0 || line.startsWith('#')) {\n    return false;\n  }\n  return true;\n}\n\nexport {\n  shouldReadLine\n };\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Assertion, Node} from './graph.js';\nimport * as utils from './utils.js'\nconst NAMESPACES = ['l', 'schema', 'dcs', 'dcid'];\nconst LOCAL_NS = 'l';\n\n\n/** Class responsible for parsing an mcf file. */\nclass ParseMCF {\n  /**\n   * Create a ParseMCF object which keeps tracks of the current source node of\n   * each triple in the mcf and the provenance, which is the mcf file name.\n   */\n  constructor() {\n    this.curNode = null;\n    this.prov = null;\n  }\n\n  handleNodeValue(parsedValues) {\n    if (parsedValues.length === 1) {\n      if (parsedValues[0] instanceof Object ) {\n\n        this.curNode = Node.getNode(parsedValues[0]['ref'], /* shouldCreate */ true);\n\n        if (parsedValues[0]['ns'] !== LOCAL_NS) {\n          this.curNode.setDCID(parsedValues[0]['ref']);\n        }\n      } else {\n        this.curNode = Node.getNode(parsedValues[0], /* shouldCreate */ true);\n      }\n      Node.nodeLocalHash[this.curNode.localID] = this.curNode;\n    } else {\n      console.log('Error in declaring node: ' + parsedValues);\n    }\n  }\n\n  createAssertionsFromValues(propLabel, parsedValues) {\n    for (const val of parsedValues) {\n      let target;\n      if (val instanceof Object) {\n\n          target = Node.getNode(val['ref'], /* shouldCreate */ true);\n\n        if (val['ns'] !== LOCAL_NS) {\n          target.setDCID(val['ref']);\n        }\n      } else {\n        // add value AddAssertion\n        target = val;\n      }\n      // return for the sake of testing,\n      // calling Assertion.addAssertion would be sufficient\n      return Assertion.addAssertion(this.curNode, propLabel, target, this.prov);\n    }\n  }\n\n  /**\n   * Parses a string represetnaing a comma separated list of property values from\n   * a line of an mcf file. Returns a list having either a string or\n   * <namespace, reference> pair.\n   *\n   * @param {string} propValues A comma separated list of property values.\n   * @return {Array<string|<namespace, reference>>} Array of parsed values.\n   */\n\n   /**\n    * Returns the property label of the line.\n    * @param {string} line The line to be read.\n    * @return {string|null} The property label if the line has one.\n    */\n   static getPropLabel(line) {\n     if (line.split(':').length >= 2) {\n       return line.split(':')[0].trim();\n     }\n\n     console.log('ERROR Line does not contain colon: ' + line);\n     return null;\n   }\n\n  static parsePropValues(propValues) {\n    const values = [];\n    for (const propValue of propValues.split(',')) {\n      if (propValue.split(':').length === 2) {\n        const namespace = propValue.split(':')[0].trim();\n        if (NAMESPACES.indexOf(namespace) >= 0) {\n          values.push({\n            'ns': namespace,\n            'ref': propValue.split(':')[1].trim(),\n          });\n          continue;\n        }\n      }\n      values.push(propValue.trim()); // case: goId: \"GO:12345\"\n    }\n    return values;\n  }\n\n  /**\n   * Parses a single line of an mcf file. First determines if the line should be\n   * read, then finds the property label, then the property values and creates\n   * an Assertion object based on the triple, given the calling object has a\n   * curNode property that acts as the source  and a prov property that gives\n   * the provenance for the triple.\n   *\n   * @param {string} line The line of mcf to be parsed.\n   */\n  parseLine(line) {\n    line = line.trim();\n\n    if (!utils.shouldReadLine(line)) return;\n\n    if (!line.includes(':')) return;\n\n    const propLabel = line.substring(0,line.indexOf(':'))\n    const propValues = line.substring(line.indexOf(':')+1)\n\n    if (!propValues) return;\n\n    // parsePropValues() returns a list having either a string or <namespace, reference> pair.\n    const parsedValues = ParseMCF.parsePropValues(propValues);\n\n    switch (propLabel) {\n      case 'Node':\n        this.handleNodeValue(parsedValues);\n        break;\n\n      case 'dcid':\n        if (this.curNode && parsedValues.length === 1 &&\n          typeof parsedValues[0] === 'string' ) {\n          this.curNode.setDCID(parsedValues[0].replace(/\"/g, ''));\n        } else {\n          console.log('ERROR dcid prop declared before Node:' + line);\n        }\n        break;\n\n      default:\n        this.createAssertionsFromValues(propLabel, parsedValues);\n    }\n  }\n\n  /**\n   * Parses each line of the given string of an mcf file after setting the prov\n   * property of the calling ParseMCF object.\n   * @param {string} mcf The string representation of an mcf file to parse.\n   * @param {string} fileName The name of file that mcf string comes from.\n   * @return {Object} The mapping from local subject id to node, for home page.\n   */\n  parseMCFStr(mcf, fileFullName) {\n    // remove file extension to keep only filename as provenance\n    const fileNameSpiltOnPeriod = fileFullName.split('.');\n    fileNameSpiltOnPeriod.pop();\n    const fileName = fileNameSpiltOnPeriod.join('.');\n    this.prov = 'local: ' + fileName;\n\n    // parse each line of the mcf\n    const lines = mcf.split('\\n');\n    for (const line of lines) {\n      this.parseLine(line);\n    }\n    return Node.nodeLocalHash;\n  }\n\n  /**\n   * Reads an mcf file into a string, then creates ParseMCF object to parse the\n   * string.\n   * @param {FileObject} file An mcf file from the html file-input element.\n   * @return {Promise} Promise resolves to Node.nodeLocalHash after parsing mcf.\n   */\n  static readFile(file) {\n    const fileReader = new FileReader();\n    fileReader.readAsText(file);\n    return new Promise((res, rej) => {\n      fileReader.addEventListener('loadend', (result) => {\n        const mcfParser = new ParseMCF();\n        res(mcfParser.parseMCFStr(fileReader.result, file.name));\n      });\n\n      fileReader.addEventListener('error', rej);\n    });\n  }\n}\nexport { ParseMCF };\n\n// Todo fix bug in parsing geneOntologyID: \"GO:idNum\"\n// currently gives error in namespace\n","/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n import * as utils from './utils.js'\n\nconst csv = require('csvtojson');\n\n/**\n * Returns the string following '->' in  a given string. Used for getting csv\n * column name when filling in tmcf with values from csv.\n * Ex:   C:SomeDataset->GeoId would return 'GeoId'\n * @param {string} propValue The string to look for a column name in.\n * @return {string|null} The column name that comes after '->'.\n */\nfunction getArrowId(propValue) {\n  if (propValue.includes('->')) {\n    return propValue.split('->')[1];\n  }\n  return null;\n}\n\n/**\n * Returns a string matching the format E:'DataSet Name'->'Entity #'.\n * @param {string} line The string to look for a match in.\n * @return {string|null} The entity id that matches the specified format.\n */\nfunction getEntityID(line) {\n  const localIDMatch = line.match('E:(.*)->(.*)');\n  if (localIDMatch) {\n    return localIDMatch[0];\n  }\n  return null;\n}\n\n/**\n * Generates a local id for a node of specfic row in csv from an entity id used\n * in tmcf file.\n * Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n * @param {string} entityID The entity id used in tmcf file.\n * @param {string} index The row number in the csv of the node to be created.\n * @return {string|null} The local id for the node of the specific csv row.\n */\nfunction getLocalIDFromEntityID(entityID, index) {\n  if (entityID) {\n    return 'l:' + entityID.replace('->', '_').replace('E:', '') + '_R' + index;\n  }\n  return null;\n}\n\n/**\n * Converts propertyValues from a line of tmcf to mcf by either converting\n * entity ids to local ids or replacing a csv column reference with the actual\n * value from the csv.\n *\n * @param {string} propValues The property values from the line of TMCF.\n * @param {Object} csvRow The JSON representation of a single row of a csv file.\n *     The keys are the column names and values are the corresponding entries of\n *     the csv for the specfic row/column.\n * @param {number} index The row number of the csvRow, used to generate a local\n *     id if needed.\n * @return {string} The mcf version of the given propValues which has local ids\n *     in lieu of entity ids and csv column references replaces with csv values.\n */\nfunction parsePropertyValues(propValues, csvRow, index) {\n  const parsedValues = [];\n\n  for (const propValue of propValues.split(',')) {\n    let parsedValue = propValue;\n\n    const entityID = getEntityID(propValue);\n\n    // convert entity id format to local id format\n    // Ex: E:SomeDataset->E1 => SomeDataset_E1_R<index>\n    if (entityID) {\n      const localID = getLocalIDFromEntityID(entityID, index);\n      parsedValue = parsedValue.replace(entityID, localID);\n    } else {\n      // Replace csv column placeholder with the value\n      const colName = getArrowId(propValue);\n      parsedValue = parsedValue.replace(/C:(.*)->(.*)/, csvRow[colName]);\n    }\n    parsedValues.push(parsedValue);\n  }\n  return parsedValues.join(',');\n}\n\n/**\n * Convert a row of csv to mcf using the tmcf as a template.\n * @param {string} template The string representation of tmcf file.\n * @param {Object} csvRow The JSON representation of a single row of a csv file.\n *     The keys are the column names and values are the corresponding entries of\n *     the csv for the specfic row/column.\n * @param {number} index The row number of the csvRow, used to generate a local\n *     id if needed.\n * @return {string} The constructed mcf for the single row from csv file.\n */\nfunction fillTemplateFromRow(template, csvRow, index) {\n  const filledTemplate = [];\n  for (const line of template.split('\\n')) {\n    if (!line.trim()) {\n      filledTemplate.push('');\n      continue;\n    }\n\n    if (!utils.shouldReadLine(line)) continue;\n\n    const propLabel = line.split(':')[0];\n    const propValues = line.replace(propLabel + ':', '').trim();\n\n    const parsedValues = parsePropertyValues(propValues, csvRow, index);\n\n    filledTemplate.push(propLabel + ': ' + parsedValues);\n  }\n  return filledTemplate.join('\\n');\n}\n\n/**\n * Creates an mcf string from a string representation of TMCF file and the json\n * representation of a CSV file. The tmcf is populated with csv files for each\n * row of the csv.\n * @param {string} template The string representation of a tmcf file.\n * @param {Array<Object>} csvRows The json representation of the csv file. Each\n *     Object element of the array represents one row of the csv.\n * @return {string} The created mcf as a string.\n */\nfunction csvToMCF(template, csvRows) {\n  let index = 1;\n  const mcfStrList = [];\n  for (const row of csvRows) {\n    console.log(row)\n    mcfStrList.push(fillTemplateFromRow(template, row, index));\n    index += 1;\n  }\n  return mcfStrList.join('\\n');\n}\n\n/**\n * Converts CSV file to an array of JS Object where each JS Object in the array\n * represents one row of the csv. The keys of the object are the column header\n * names and the values of the object are the csv entries in that column of the\n * given row the object represents.\n * @param {string} template The string representation of a tmcf file.\n * @param {FileObject} csvFile THe csv file from html file-input element.\n * @return {Array<Object>} The json representation of the csv file.\n */\nasync function readCSVFile(template, csvFile) {\n  const fileReader = new FileReader();\n  fileReader.readAsText(csvFile);\n  return new Promise((res, rej) => {\n    fileReader.addEventListener('loadend', (result) => {\n      csv().fromString(fileReader.result).then((csvRows) => {\n        console.log(csvRows)\n        console.log('csvFile: ' + csvFile.name)\n        const mcf = csvToMCF(template, csvRows);\n        res(mcf);\n      });\n    });\n    fileReader.addEventListener('error', rej);\n  });\n}\n\n/**\n * Reads a tmcf file and returns the contents as a string\n * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n * @return {string} The string representation of the tmcf file.\n */\nasync function readTMCFFile(tmcfFile) {\n  const fileReader = new FileReader();\n  fileReader.readAsText(tmcfFile);\n  return new Promise((res, rej) => {\n    fileReader.addEventListener('loadend', (result) => {\n      res(fileReader.result);\n    });\n    fileReader.addEventListener('error', rej);\n  });\n}\n\n\n/**\n * Converts a TMCF file and CSV file to an MCF string.\n * @param {FileObject} tmcfFile The tmcf file from html file-input element.\n * @param {FileObject} csvFile THe csv file from html file-input element.\n * @return {string} The translated mcf as a string.\n */\nasync function tmcfCSVToMCF(tmcfFile, csvFile) {\n  return readTMCFFile(tmcfFile)\n      .then((template) => readCSVFile(template, csvFile));\n}\n\nexport {\n  tmcfCSVToMCF, csvToMCF, fillTemplateFromRow, getLocalIDFromEntityID,\n  getEntityID, getArrowId, parsePropertyValues,\n};\n","import {ParseMCF} from './parse-mcf.js';\nimport * as ParseTMCF from './parse-tmcf.js';\nimport {Node} from './graph.js';\n\n/**\n* Parses App state's fileList to find either one mcf file or one set of\n* tmcf+csv. Parses the files according to their file type.\n* @param {Array<FileBlob>} fileList The list of files to load into memory.\n* @return {Array<string>} An array of local ids from Node.nodeLocalHash.\n*/\nasync function readFileList(fileList) {\n  let tmcfFile;\n  let csvFile;\n  let mcfFile;\n  for (const file of fileList) {\n    console.log(file);\n    if (file.name.endsWith('.tmcf')) {\n      tmcfFile = file;\n    } else if (file.name.endsWith('.mcf')) {\n      mcfFile = file;\n    } else {\n      csvFile = file;\n    }\n  }\n\n  if (mcfFile) {\n    return ParseMCF.readFile(mcfFile)\n        .then((localHash) => Object.keys(localHash));\n  }\n\n  if (tmcfFile && csvFile) {\n    return ParseTMCF.tmcfCSVToMCF(tmcfFile, csvFile).then((mcf) => {\n      console.log(mcf);\n      const mcfParser = new ParseMCF();\n      return mcfParser.parseMCFStr(mcf, tmcfFile.name);\n    }).then((localHash) => Object.keys(localHash));\n  }\n  return [];\n}\n\nfunction clearFiles() {\n  Node.nodeHash = {};\n  Node.nodeLocalHash = {};\n  Node.dcidToLocal = {};\n}\n\n// TODO fix\nfunction retrieveNode(id, shouldCreateRemote) {\n  const foundNode = Node.getNode(id, true);\n  // should make dcid from search bar\n  if (shouldCreateRemote && !(foundNode.dcid)) foundNode.setDCID(id);\n  console.log('retrieve')\n  console.log(foundNode)\n  return foundNode;\n}\n\nfunction isNodeObj(obj) {\n  return Node.isNode(obj);\n}\n\nasync function getClassName(target) {\n  if (!target) return null;\n  if (target.existsInKG) return 'clickable-blue';\n\n  return target.setExistsInKG()\n      .then(() => {\n        console.log(target);\n        if (target.existsInKG) return 'clickable-blue';\n\n        if (!target.dcid && target.localID && target.localID in Node.nodeLocalHash) {\n          return 'clickable-purple';\n        }\n\n        if (!target.dcid && !(target.localID in Node.nodeLocalHash)) {\n          return 'clickable-orange';\n        }\n        return 'clickable-red';\n      });\n}\nexport {readFileList, clearFiles, retrieveNode, isNodeObj, getClassName};\n","/**\n * Sets the window hash value to query a given id.\n * @param {string} id The id of the desired node to display. This can be either\n *     a dcid or a local id.\n */\nfunction goToId(id) {\n  if(id.includes('dcid:')){\n  window.location.hash = '#dcid=' + id.replace('dcid:', '');\n} else{\n  window.location.hash = '#id=' + id;\n}\n}\n\n/**\n * Sets the window hash value to empty to redirect user to home page.\n */\nfunction goToHome() {\n  window.location.hash = '';\n}\nexport {goToId, goToHome};\n","import React, {Component} from 'react';\nimport * as utils from './utils.js';\nimport './App.css';\n\n/** Header component contains the id search bar and return home button. */\nclass Header extends Component {\n  /**\n   * Calls utils method goToId to search for an id when the user presses enter.\n   * @param {Event} event OnKeyUp  event from html search input element.\n   */\n  handleSearch(event) {\n    if (event.keyCode === 13) {\n      utils.goToId(event.target.value);\n    }\n  }\n  /** Renders header element. */\n  render() {\n    return (\n      <div>\n        <input className='flex' type=\"search\" onKeyUp={this.handleSearch}\n          placeholder=\"Search id, use 'dcid:' namespace for remote lookup...\" />\n        <button className='flex' onClick = {() => utils.goToHome() }>Return Home</button>\n      </div>\n    );\n  }\n}\nexport {Header};\n","import React, {Component} from 'react';\nimport './App.css';\nimport * as API from './back-end/server-api.js';\nimport * as utils from './utils.js';\n\n/**\n * Returns an html element of the missing cell value in a triple. If the current\n * triple is an outgoing assertion (current node displayed is the source of the\n * triple) then this method will be called on the target. If the current triple\n * is an inverse assertions, then this method is called on the source of the\n * triple.\n * Determines if the target is another node and should be\n * clickable, what color it should be, and the node reference that should be\n * displayed (dcid vs dcid [l:localId] vs [l:localId]). If the target is not\n * another node, then an html element of pure text is returned.\n * @param {Node|string} target The source of an inverse assertion or the target\n *     of a direct assertion.\n * @return {HtmlElement} A single cell of an html row representing a triple.\n *     Either the source or target of the triple depending if the triple is\n *     inverse or not.\n */\nasync function getMissingVal(target) {\n  if (API.isNodeObj(target)) {\n    const className = await API.getClassName(target);\n    return (\n      <td className={className} onClick={() =>\n        utils.goToId(target.localID)}>{target.getRef()}</td>\n    );\n  }\n  return (<td >{target}</td>);\n}\n\n/**\n * Returns an html element row representing the given assertion.\n * @param {Assertion} assert The assertion/triple to create the html row from.\n * @param {boolean} isInverse True if the assertion is inverse, meaning the\n *     currently displayed node is the target of the triple.\n * @param {number} index Used to create a unique key for the html row element.\n * @return {HtmlElement} A row represeting the given triple.\n */\nasync function getRowFromTriple(assert, isInverse, index ) {\n  const missingVal = isInverse ? assert.src : assert.target;\n  const val = await getMissingVal(missingVal);\n\n  const className = assert.provenance.startsWith('local:') ? 'bold' : null;\n  return (\n    <tr className={className} key={assert.property + index}>\n      {isInverse? val : null}\n      <td>{assert.property}</td>\n      {!isInverse? val : null}\n      <td>{assert.provenance}</td>\n    </tr>\n  );\n}\n/**\n * Converts a list of Assertion objects to an array of HTML row elements that is\n * displyed in the TriplesTable.\n * @param {Array<Assertion>} asserts An array of Assertion objects to display in\n *     the TriplesTable component.\n * @param {boolean} isInverse True if the current node displayed is the target\n *     for each of the assertions.\n * @return {Array<HtmlElement>} The array of HTML row elements representing each\n *     triple.\n */\nasync function getTripleRows(asserts, isInverse) {\n  const tripleRows = [];\n  let index = 0; // used to create a unique key for each row element\n\n  for (const assert of asserts) {\n    const tripleRow = await getRowFromTriple(assert, isInverse, index);\n    tripleRows.push(tripleRow);\n    index += 1;\n  }\n  return tripleRows;\n}\n\nfunction getTableHeaders(isInverse) {\n  if (isInverse) {\n    return (\n      <tr>\n        <th>source</th>\n        <th>property</th>\n        <th>provenance</th>\n      </tr>\n    );\n  }\n  return (\n    <tr>\n      <th>property</th>\n      <th>target</th>\n      <th>provenance</th>\n    </tr>\n  );\n}\n\n/** Displays all given triples as a table */\nexport class TriplesTable extends Component {\n  /** Creates TriplesTable component. */\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      tableRows: null,\n      loading: true,\n    };\n  }\n\n  /**\n   * Gets rows of triples when the array of Assertions from props is updated.\n   * @param {Object} prevProps The previous props before the component updated,\n   *     used to compare if the passed in triples have been modified.\n   */\n  componentDidUpdate(prevProps) {\n    if (prevProps.triples !== this.props.triples) {\n      this.setState({loading: true});\n      getTripleRows(this.props.triples, this.props.inverse).then((rows) => {\n        this.setState({tableRows: rows, loading: false});\n      });\n    }\n  }\n\n  /** Renders TriplesTable component.   */\n  render() {\n    if (this.state.loading) return null;\n\n    const tableHeaders = getTableHeaders(this.props.inverse);\n\n    return (\n      <table>\n        <thead>\n          {tableHeaders}\n        </thead>\n        <tbody>{this.state.tableRows}</tbody>\n      </table>\n    );\n  }\n}\n","import * as API from './back-end/server-api.js';\nimport React, {Component} from 'react';\nimport {Header} from './Header.js';\nimport {TriplesTable} from './TriplesTable.js';\nimport './App.css';\n\n/** Displays node data for a given node passed in through props. */\nclass DisplayNode extends Component {\n  /** Creates DisplayNode component. */\n  constructor(props) {\n    super(props);\n    this.state = {\n      ref: null,\n      asserts: [],\n      invAsserts: [],\n      fetching: true,\n    };\n  }\n\n  /** Sets node data when the component mounts. */\n  componentDidMount() {\n    this.setNodeData();\n  }\n\n  /**\n   * Sets node data when the node to display changes.\n   * @param {Object} prevProps The previous props before the component updated,\n   *     used to compare if the passed in node has changed.\n   */\n  componentDidUpdate(prevProps) {\n    if (prevProps.node !== this.props.node) {\n      this.setNodeData();\n    }\n  }\n\n  /**\n   * Loads data to display for the node passed in through props. This includes\n   * fetching the remote data from DC KG for the node.\n   */\n  setNodeData() {\n    console.log(this.props.node);\n\n    const curNode = this.props.node;\n    this.setState({ref: curNode.getRef(), fetching: true});\n\n    API.getClassName(curNode)\n        .then((className) => this.setState({className: className}) );\n\n    curNode.fetchRemoteData().then( () => {\n      this.setState({fetching: false});\n     const assertList = curNode.getAssertions();\n     this.setState({asserts: assertList});\n     const invAssertList = curNode.getInvAssertions();\n     this.setState({invAsserts: invAssertList});\n    });\n  }\n\n  /** Renders the DisplayNode component. */\n  render() {\n    let tables;\n    if (this.state.fetching) {\n      tables = (\n        <div>\n          <br></br>\n          <h1 className='normal'>...fetching triples...</h1>\n        </div>\n      );\n    } else {\n      tables = (\n        <div>\n          <h3>Assertions</h3>\n          <p><u>source: {this.state.ref}</u></p>\n          <TriplesTable triples={this.state.asserts} inverse={false}/>\n          <br></br>\n          <h3>Inverse Assertions</h3>\n          <p><u>target: {this.state.ref}</u></p>\n          <TriplesTable triples={this.state.invAsserts} inverse={true}/>\n        </div>\n      );\n    }\n    return (\n      <div>\n        <Header />\n        <h1 className=\n          {this.state.className}>Currently Viewing: {this.state.ref}</h1>\n        {tables}\n        <br></br>\n        <p className='clickable-blue'>Node has dcid and dcid exists in KG</p>\n        <p className='clickable-purple'>Node has resolved local reference and no dcid</p>\n        <p className='clickable-orange'>Node has no dcid and local reference is unresolved</p>\n        <p className='clickable-red'>Anything else (has dcid, but does not exist in KG)</p>\n      </div>\n    );\n  }\n}\nexport default DisplayNode;\n","import React, {Component} from 'react';\nimport './App.css';\nimport * as API from './back-end/server-api.js';\nimport * as utils from './utils.js';\nimport {Header} from './Header.js';\nimport DisplayNode from './DisplayNode.js';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      subjNodes: [],\n      curNode: null,\n      fileList: [],\n      loading: null,\n    };\n  }\n  /** Adds an event listener to the window to respond to url hash changes. */\n  componentDidMount() {\n    window.addEventListener('hashchange', () => this.handleHashChange(), false);\n    this.handleHashChange();\n  }\n\n  /**\n   * Sets App state according to url parameters 'id' and 'file'. The param 'id'\n   * will cause the display node page to appear with the node of the specified\n   * id. The 'file' param followed by url to a file will cause that file to be\n   * loaded and parsed if it is one url to mcf or two 'file' params with one a\n   * url to a tmcf and the other a url to a csv file.\n   */\n  handleHashChange() {\n    const params = new URLSearchParams(window.location.hash.split('#')[1]);\n    // get node to display from url\n\n    let node;\n    const searchDCId = params.get('dcid');\n    if (searchDCId) {\n       node = API.retrieveNode(searchDCId, /* shouldCreateRemote */ true);\n      this.setState({curNode: node});\n      console.log(node)\n    }\n    const searchId = params.get('id');\n    if (searchId) {\n       node = API.retrieveNode(searchId, /* shouldCreateRemote */ false);\n      this.setState({curNode: node});\n    }\n    if (!node) {\n      this.setState({curNode: null});\n    }\n    // get path to file(s) from urls\n    const fileUrls = params.getAll('file');\n    if (fileUrls.length) {\n      this.getRemoteFile(0, fileUrls);\n    }\n  }\n\n  /**\n   * Gets a remote file from an Array of urls at index i and appends the\n   * retrieved file to App state's fileList. This is a recursive method that\n   * calls itself to iterate through the entire Array of fileUrls.\n   * @param {number} i The index of the url to get from fileUrls array.\n   * @param {Array<string>} fileUrls The array of file urls to load and append\n   *     to App state's fileList.\n   */\n  getRemoteFile(i, fileUrls) {\n    if (i >= fileUrls.length) {\n      return;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'blob';\n    xhr.open('GET', fileUrls[i]);\n    console.log('loading: ' + fileUrls[i]);\n    xhr.onload = () => {\n      console.log('finished loading');\n      console.log(xhr.response);\n      xhr.response.name=fileUrls[i];\n      this.setState({fileList: this.state.fileList.concat(xhr.response)});\n      this.getRemoteFile(i+1, fileUrls);\n    };\n    xhr.send();\n  }\n\n  /**\n   * Passes App state's fileList array to the 'back-end' API to be parsed and\n   * the files loaded into memory.\n   */\n  submitFileList() {\n    this.setState({loading: <h1>...loading mcf...</h1>});\n\n    API.readFileList(this.state.fileList)\n        .then( (subjList) => this.setState({subjNodes: subjList, loading: null}));\n  }\n\n  /**\n   * Clear App state and calls the 'back-end' API clearFiles method.\n   */\n  onClearPress() {\n    this.setState({subjNodes: [], fileList: [], loading: null});\n    API.clearFiles();\n  }\n  /** Renders the browser by displaying a specific node or the homepage. */\n  render() {\n    if (this.state.curNode) {\n      return (\n      \t<DisplayNode node={this.state.curNode} />\n      );\n    }\n\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <Header />\n          <div className=\"div-col\">\n            <h3>Upload one MCF file or one set of TMCF+CSV files to preview in Data Commons.</h3>\n            <input id=\"file-select\" onChange={ (event) =>\n              this.setState({fileList: this.state.fileList.concat(Array.from(event.target.files))}) }\n            type=\"file\" name=\"UploadFile\" accept=\".mcf,.tmcf,.csv\" required multiple />\n            <br></br>\n            <h3>Current Files:</h3>\n            <ul>{this.state.fileList.map( (file) =>\n              <li key={file.name}>{file.name}</li>,\n            )}</ul>\n            <button onClick={() => this.submitFileList()} >Submit</button>\n            <br></br>\n            <button onClick={() => this.onClearPress()} >Clear</button>\n            <h3>Subject Nodes:</h3>\n            <ul>{this.state.subjNodes.map( (dcid) =>\n              <li key={dcid} onClick={() => utils.goToId(dcid)}>{dcid}</li>,\n            )}</ul>\n            {this.state.loading}\n          </div>\n        </header>\n      </div>\n\n    );\n  }\n}\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n"],"sourceRoot":""}